// Generated by CoffeeScript 1.6.3
(function() {
  var BuiltInObjects, Clone, DefaultPkFactory, MongoObjects, ObjectID, applyToRegistered, async, commit, commitWithGlobalLock, execute, rollback, _chainCounter, _checkForChain, _checkTransaction, _clone, _commitCore, _config, _db, _drainQueues, _enqueue, _enqueueAndHandleChains, _executeImmediate, _hasAfter, _hasBefore, _immediateCounter, _immediately, _inSeries, _instructionsExistFor, _makeUpdateOptions, _mongoFlatten, _mongoOpsFromTo, _pending, _pendingImmediate, _pkFactory, _processRevisions, _pushTransactionError, _queueCountersCollection, _queueLength, _queuePosition, _queues, _registry, _registryFind, _requeue, _setUpTransaction, _shiftChain, _softwareVersion, _state, _transactionsCollection, _updateOpInstruction, _updateOpRollback, _updateTransactionState, _updateTransactionStatus, _withGlobalLock,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  ObjectID = null;

  MongoObjects = null;

  BuiltInObjects = [Array, Boolean, Date, Number, String, RegExp];

  _state = 'stopped';

  _queueLength = {};

  _immediateCounter = 0;

  _chainCounter = 0;

  _queues = null;

  _db = null;

  _registry = {};

  _pending = [];

  _pendingImmediate = [];

  _softwareVersion = null;

  _queueCountersCollection = null;

  _transactionsCollection = null;

  _pkFactory = null;

  _config = {};

  exports.util = {};

  Clone = require('clone');

  _clone = function(x) {
    return Clone(x, false);
  };

  DefaultPkFactory = (function() {
    function DefaultPkFactory() {}

    DefaultPkFactory.prototype.createPk = function() {
      return new ObjectID();
    };

    return DefaultPkFactory;

  })();

  _inSeries = function(cursor, fn, done) {
    var finished;
    finished = false;
    return async.doUntil(function(itemDone) {
      return cursor.nextObject(function(err, item) {
        if (err != null) {
          return itemDone(err);
        }
        if (item == null) {
          finished = true;
          return itemDone();
        } else {
          return fn(item, itemDone);
        }
      });
    }, function() {
      return finished;
    }, function(err) {
      return done(err);
    });
  };

  exports.start = function(config, done) {
    var e, t, tasks;
    if ((config != null ? config.db : void 0) == null) {
      return done(new Error("committed must be supplied with at least a config.db during start"));
    }
    if ((config != null ? config.MongoNativeModule : void 0) == null) {
      return done(new Error("commited must be supplied with an MongoNativeModule, like require('mongodb')"));
    }
    ObjectID = config.MongoNativeModule.ObjectID;
    try {
      new ObjectID();
    } catch (_error) {
      e = _error;
      return done(new Error("commited must be supplied with an MongoNativeModule, like require('mongodb')"));
    }
    MongoObjects = (function() {
      var _i, _len, _ref, _results;
      _ref = ['ObjectID', 'Binary', 'Code', 'DBRef', 'Double', 'MinKey', 'MaxKey', 'Symbol', 'Timestamp', 'Long'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(config.MongoNativeModule[t]);
      }
      return _results;
    })();
    if (_state !== 'stopped') {
      return done(new Error("committed has already been started"));
    }
    _softwareVersion = config.softwareVersion;
    _pkFactory = config.pkFactory != null ? config.pkFactory : new DefaultPkFactory();
    _db = config.db;
    _config = config;
    _queueLength = {};
    _immediateCounter = 0;
    _pending = [];
    _pendingImmediate = [];
    _queues = {
      GlobalLock: async.queue(commitWithGlobalLock, 1)
    };
    _queueLength.GlobalLock = 0;
    _queues.GlobalLock.drain = function() {
      var transaction, _ref, _ref1, _results;
      _state = 'started';
      while (_pending.length !== 0) {
        _ref = _pending.shift(), transaction = _ref[0], done = _ref[1];
        _enqueueAndHandleChains(transaction, done);
      }
      _results = [];
      while (_pendingImmediate.length !== 0) {
        _ref1 = _pendingImmediate.shift(), transaction = _ref1[0], done = _ref1[1];
        _results.push(_executeImmediate(transaction, done));
      }
      return _results;
    };
    tasks = [];
    tasks.push(function(done) {
      return _db.createCollection('transactions', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _transactionsCollection = collection;
        return _db.ensureIndex('transactions', {
          status: 1
        }, {
          w: 1,
          journal: true
        }, function(err) {
          if (err != null) {
            return done(err, null);
          }
          return _db.ensureIndex('transactions', {
            'after.0.status': 1
          }, {
            w: 1,
            journal: true
          }, function(err) {
            return done(err, null);
          });
        });
      });
    });
    tasks.push(function(done) {
      return _db.createCollection('queueCounters', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _queueCountersCollection = collection;
        return _db.ensureIndex('queueCounters', {
          queue: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _inSeries(_transactionsCollection.find({
        status: 'Processing'
      }, {
        sort: {
          position: 1
        }
      }), function(transaction, transactionDone) {
        return rollback(transaction, function(err, result) {
          if (err != null) {
            console.error(err.name, err.message, err.stack);
          }
          return transactionDone();
        });
      }, done);
    });
    tasks.push(function(done) {
      return _inSeries(_transactionsCollection.find({
        status: 'Committed',
        "after.0.status": 'Queued'
      }), function(transaction, transactionDone) {
        _shiftChain(transaction);
        return _transactionsCollection.save(transaction, {
          w: 1,
          journal: true
        }, function(err, result) {
          if (err != null) {
            console.error(err.name, err.message, err.stack);
          }
          return transactionDone();
        });
      }, done);
    });
    tasks.push(function(done) {
      return _inSeries(_transactionsCollection.find({
        status: 'Queued'
      }, {
        sort: {
          position: 1
        }
      }), function(transaction, transactionDone) {
        return _enqueueAndHandleChains(transaction, function() {
          var err, results, status;
          err = arguments[0], status = arguments[1], results = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
          if (err != null) {
            console.error(err.name, err.message, err.stack, JSON.stringify(transaction, null, 2));
          }
          return transactionDone();
        });
      }, done);
    });
    return async.series(tasks, function(err, results) {
      if (err != null) {
        return done(err);
      }
      _state = 'started';
      return done(null);
    });
  };

  exports.stop = function(done) {
    if (_state === 'stopped') {
      return done(new Error("committed is not currently started"));
    }
    return setImmediate(function() {
      _state = 'stopped';
      return _drainQueues([], done);
    });
  };

  _drainQueues = function(exceptQueues, done) {
    return async.until(function() {
      var count, name;
      return ((function() {
        var _results;
        _results = [];
        for (name in _queueLength) {
          count = _queueLength[name];
          if (__indexOf.call(exceptQueues, name) < 0) {
            _results.push(count === 0);
          }
        }
        return _results;
      })()).every(function(x) {
        return x;
      }) && _immediateCounter === 0;
    }, function(untilBodyDone) {
      return setTimeout(untilBodyDone, 10);
    }, function(err) {
      return done(err);
    });
  };

  exports.register = function(name, fnOrObj) {
    var ancestor, ancestors, key, parent, _i, _len;
    parent = _registry;
    ancestors = name.split('.');
    key = ancestors.pop();
    for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
      ancestor = ancestors[_i];
      parent = parent[ancestor];
      if (parent == null) {
        throw new Error("during register: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry)));
      }
    }
    if (parent[key] != null) {
      throw new Error("during register: path " + name + " already exists in registry: " + (JSON.stringify(_registry)));
    }
    return parent[key] = fnOrObj;
  };

  _queuePosition = function(queueName, done) {
    return _queueCountersCollection.findAndModify({
      queue: queueName
    }, {}, {
      $inc: {
        nextPosition: 1
      }
    }, {
      upsert: true,
      w: 1,
      journal: true
    }, function(err, doc) {
      var _ref;
      if (err != null) {
        return done(err, null);
      }
      return done(null, (_ref = doc.nextPosition) != null ? _ref : 0);
    });
  };

  _enqueueAndHandleChains = function(transaction, done) {
    var chainGuard, decrementQueueCounter, isChain, lastStatus, results;
    isChain = ((transaction != null ? transaction.after : void 0) != null) && ((transaction != null ? transaction.before : void 0) != null);
    results = [];
    lastStatus = null;
    chainGuard = null;
    decrementQueueCounter = function(queueName) {
      if (_queueLength[queueName] != null) {
        _queueLength[queueName] -= 1;
        if (_queueLength[queueName] === 0) {
          return delete _queueLength[queueName];
        }
      }
    };
    return async.doWhilst(function(bodyDone) {
      var _name;
      if (_queues[transaction.queue] == null) {
        _queues[transaction.queue] = async.queue(commit, 1);
        _queues[transaction.queue].drain = function() {
          return delete _queues[transaction.queue];
        };
      }
      if (_queueLength[_name = transaction.queue] == null) {
        _queueLength[_name] = 0;
      }
      _queueLength[transaction.queue] += 1;
      if (chainGuard != null) {
        decrementQueueCounter(chainGuard);
        chainGuard = null;
      }
      return _queues[transaction.queue].push(transaction, function() {
        var err, newResults, newTransaction, originalTransaction, result, status, _i, _len;
        err = arguments[0], newTransaction = arguments[1], status = arguments[2], newResults = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
        originalTransaction = transaction;
        if (transaction.fnType === 'writer') {
          transaction = newTransaction;
          isChain = ((transaction != null ? transaction.after : void 0) != null) && ((transaction != null ? transaction.before : void 0) != null);
        }
        if (!isChain) {
          decrementQueueCounter(originalTransaction.queue);
        } else {
          chainGuard = originalTransaction.queue;
        }
        for (_i = 0, _len = newResults.length; _i < _len; _i++) {
          result = newResults[_i];
          results.push(result);
        }
        lastStatus = status;
        return setImmediate(bodyDone, err);
      });
    }, function() {
      if (isChain) {
        if (lastStatus === 'Committed') {
          if (_hasAfter(transaction)) {
            _shiftChain(transaction);
            return true;
          } else {
            return false;
          }
        } else {
          if (!_hasBefore(transaction)) {
            return false;
          } else {
            lastStatus = 'ChainFailed';
            return false;
          }
        }
      } else {
        return false;
      }
    }, function(err) {
      if (chainGuard != null) {
        decrementQueueCounter(chainGuard);
        chainGuard = null;
      }
      if (err != null) {
        return done.apply(null, [err, lastStatus].concat(__slice.call(results)));
      } else if (transaction.fnType === 'reader') {
        return done.apply(null, [err].concat(__slice.call(results)));
      } else if (lastStatus === 'ChainFailed') {
        return _updateTransactionStatus(transaction, transaction.status, 'ChainFailed', null, null, transaction.status, function(statusErr) {
          if (statusErr != null) {
            return done.apply(null, [statusErr, transaction.status].concat(__slice.call(results)));
          }
          return done.apply(null, [err, 'ChainFailed'].concat(__slice.call(results)));
        });
      } else {
        return done.apply(null, [err, lastStatus].concat(__slice.call(results)));
      }
    });
  };

  _checkTransaction = function(transaction) {
    var after, i, key, result, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if ((transaction.status != null) && transaction.status !== 'Queued') {
      return new Error("Can't queue a transaction which is at a status other than Queued (or null)");
    }
    if ((transaction.queue != null) && (_config.queueNameRegex != null) && !_config.queueNameRegex.test(transaction.queue)) {
      return new Error("transaction.queue name " + transaction.queue + " does not match required regex " + (_config.queueNameRegex.toString()));
    }
    if (typeof transaction !== 'function') {
      _ref = transaction.instructions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        for (key in i) {
          if (key !== 'name' && key !== 'arguments') {
            return new Error("can't queue a transaction with an instruction that contains key '" + key + "', instructions can contain only 'name' and 'arguments' keys");
          }
        }
      }
      if (!_instructionsExistFor(transaction)) {
        return new Error("Can't queue a transaction for which either its instructions, rollback instructions, or implied auto rollback instructions don't exist in the registry");
      }
      if ((transaction.rollback != null) && transaction.rollback.length !== transaction.instructions.length) {
        return new Error("Can't queue a transaction with an explicit rollback instructions whose length is not the same as its instructions array");
      }
      if (transaction.after != null) {
        if (!transaction.after.every(function(x) {
          return (x.status != null) && x.status === 'Queued';
        })) {
          return new Error("Can't queue a transaction chain where one transaction is at a status other than Queued");
        }
        _ref1 = transaction.after;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          after = _ref1[_j];
          result = _checkTransaction(after);
          if (result != null) {
            return result;
          }
        }
      }
    } else {
      if ((transaction.fnType == null) || ((_ref2 = transaction.fnType) !== 'reader' && _ref2 !== 'writer')) {
        return new Error("can't queue a function which doesn't have a fnType of 'reader' or 'writer'");
      }
    }
  };

  _instructionsExistFor = function(transaction) {
    var i, _i, _j, _len, _len1, _ref, _ref1;
    if (transaction.rollback != null) {
      _ref = transaction.instructions.concat(transaction.rollback);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (_registryFind(i.name) == null) {
          return false;
        }
      }
    } else {
      _ref1 = transaction.instructions;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        i = _ref1[_j];
        if (_registryFind(i.name) == null) {
          return false;
        }
        if (_registryFind(i.name + 'Rollback') == null) {
          return false;
        }
      }
    }
    return true;
  };

  _setUpTransaction = function(transaction) {
    var i, iRoll, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (transaction.rollback == null) {
      transaction.rollback = [];
      _ref = transaction.instructions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        iRoll = _clone(i);
        iRoll.name = iRoll.name + 'Rollback';
        transaction.rollback.push(iRoll);
      }
    }
    transaction.execution.state = [];
    _ref1 = transaction.instructions;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      i = _ref1[_j];
      _results.push(transaction.execution.state.push({}));
    }
    return _results;
  };

  _checkForChain = function(transactionArg, done) {
    var error, transaction;
    try {
      transaction = Array.isArray(transactionArg) ? exports.chain(transactionArg) : transactionArg;
    } catch (_error) {
      error = _error;
      return done(error);
    }
    return done(null, transaction);
  };

  _enqueue = function(transactionArg, done) {
    return _checkForChain(transactionArg, function(err, transaction) {
      var error, _ref;
      if (err != null) {
        return done(err);
      }
      transaction.enqueuedAt = new Date();
      if (transaction.queue === "GlobalLock") {
        return done(new Error("Can't queue a transaction for GlobalLock using the committed.enqueue function"), null);
      }
      if (!((_ref = transaction.queue) != null ? _ref.length : void 0)) {
        return done(new Error("must have a transaction.queue parameter to use committed.enqueue"), null);
      }
      error = _checkTransaction(transaction);
      if (error != null) {
        return done(error, null);
      }
      transaction.status = 'Queued';
      if (_state !== 'locked') {
        return _enqueueAndHandleChains(transaction, done);
      } else {
        return _pending.push([transaction, done]);
      }
    });
  };

  exports.enqueue = function(transaction, done) {
    return setImmediate(function() {
      if (_state === 'stopped') {
        return done(new Error("unable to enqueue transaction, committed was at state '" + _state + "'"), null);
      } else {
        return _enqueue(transaction, done);
      }
    });
  };

  exports.immediately = function(transaction, done) {
    return setImmediate(function() {
      if (_state === 'stopped') {
        return done(new Error("unable to execute transaction immediately, committed was at state '" + _state + "'"), null);
      } else {
        return _immediately(transaction, done);
      }
    });
  };

  _executeImmediate = function(transaction, done) {
    _immediateCounter += 1;
    return commit(transaction, function() {
      var err, etc, status, transaction;
      err = arguments[0], transaction = arguments[1], status = arguments[2], etc = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      _immediateCounter -= 1;
      return done.apply(null, [err, status].concat(__slice.call(etc)));
    });
  };

  _immediately = function(transactionArg, done) {
    return _checkForChain(transactionArg, function(err, transaction) {
      var error;
      if (err != null) {
        return done(err);
      }
      transaction.enqueuedAt = new Date();
      if (transaction.queue != null) {
        return done(new Error("Can't call committed.immediately on a transaction which has a queue defined for it"));
      }
      error = _checkTransaction(transaction);
      if (error != null) {
        return done(error, null);
      }
      if (_state !== 'locked') {
        transaction.status = 'Queued';
        transaction.position = -1;
        return _executeImmediate(transaction, done);
      } else {
        return _pendingImmediate.push([transaction, done]);
      }
    });
  };

  _withGlobalLock = function(transactionArg, done) {
    return _checkForChain(transactionArg, function(err, transaction) {
      var error;
      if (err != null) {
        return done(err);
      }
      if (transaction.queue !== "GlobalLock") {
        return done(new Error("Can't call committed.withGlobalLock for a transaction that names a queue other than 'GlobalLock'"), null);
      }
      error = _checkTransaction(transaction);
      if (error != null) {
        return done(error, null);
      }
      transaction.enqueuedAt = new Date();
      return _enqueueAndHandleChains(transaction, done);
    });
  };

  exports.withGlobalLock = function(transaction, done) {
    return setImmediate(function() {
      if (_state === 'stopped') {
        return done(new Error("unable to execute transaction with Global Lock, committed was at state '" + _state + "'"), null);
        return done(null, 'Failed');
      } else {
        transaction.status = "Queued";
        _state = 'locked';
        return _withGlobalLock(transaction, done);
      }
    });
  };

  _registryFind = function(name) {
    var found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        return null;
      }
    }
    return found;
  };

  applyToRegistered = function(name, fnArgs) {
    var done, found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        done = fnArgs[fnArgs.length - 1];
        return done(new Error("during applyToRegistered: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry))));
      }
    }
    return found.apply(this, fnArgs);
  };

  execute = function(instructions, state, transaction, done) {
    var allResults, i, instruction, instructionsWithState, iterator, statuses;
    statuses = [];
    allResults = [];
    iterator = function(_arg, iteratorDone) {
      var args, fnArgs, instruction, state;
      instruction = _arg[0], state = _arg[1];
      args = instruction["arguments"] != null ? instruction["arguments"] : [];
      if (!Array.isArray(args)) {
        args = [args];
      }
      fnArgs = [_config, transaction, state, args];
      fnArgs.push(function() {
        var err, result, results, status, _i, _len;
        err = arguments[0], status = arguments[1], results = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        if ((err == null) && status === false) {
          err = 'instructionFailed';
        }
        statuses.push(status);
        if (results != null) {
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            result = results[_i];
            allResults.push(result);
          }
        }
        return iteratorDone(err);
      });
      return applyToRegistered(instruction.name, fnArgs);
    };
    instructionsWithState = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = instructions.length; _i < _len; i = ++_i) {
        instruction = instructions[i];
        _results.push([instruction, state[i]]);
      }
      return _results;
    })();
    return async.eachSeries(instructionsWithState, iterator, function(err) {
      if (err === 'instructionFailed') {
        err = null;
      }
      return done(err, statuses, allResults);
    });
  };

  _pushTransactionError = function() {
    var done, error, mongoOps, optional, results, rollbackResults, serialisedError, transaction, _i;
    transaction = arguments[0], error = arguments[1], optional = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), done = arguments[_i++];
    if (optional != null) {
      results = optional[0], rollbackResults = optional[1];
    }
    if ((error.name != null) && (error.stack != null) && (error.message != null)) {
      serialisedError = {
        name: error.name,
        message: error.message,
        stack: error.stack
      };
    } else {
      serialisedError = error.toString();
    }
    mongoOps = {
      $push: {
        'execution.errors': serialisedError
      }
    };
    transaction.execution.errors.push(serialisedError);
    if (results != null) {
      transaction.execution.results = results;
      if (mongoOps.$set == null) {
        mongoOps.$set = {};
      }
      mongoOps.$set['execution.results'] = results;
    }
    if (rollbackResults != null) {
      transaction.execution.rollback = rollbackResults;
      if (mongoOps.$set == null) {
        mongoOps.$set = {};
      }
      mongoOps.$set['execution.rollback'] = rollbackResults;
    }
    return _transactionsCollection.update({
      _id: transaction._id
    }, mongoOps, {
      w: 1,
      journal: true
    }, function(err, updated) {
      if (err != null) {
        console.log("error saving error to transaction: " + err);
      }
      return done();
    });
  };

  _updateTransactionStatus = function() {
    var done, fromStatus, optional, results, rollbackResults, toStatus, transaction, updatedAt, _i;
    transaction = arguments[0], fromStatus = arguments[1], toStatus = arguments[2], optional = 5 <= arguments.length ? __slice.call(arguments, 3, _i = arguments.length - 1) : (_i = 3, []), done = arguments[_i++];
    if (optional != null) {
      results = optional[0], rollbackResults = optional[1];
    }
    updatedAt = new Date();
    if (results != null) {
      transaction.execution.results = results;
    }
    if (rollbackResults != null) {
      transaction.execution.rollback = rollbackResults;
    }
    return _transactionsCollection.update({
      _id: transaction._id,
      status: fromStatus
    }, {
      $set: {
        status: toStatus,
        softwareVersion: _softwareVersion,
        enqueuedAt: transaction.enqueuedAt,
        startedAt: transaction.startedAt,
        lastUpdatedAt: updatedAt,
        execution: transaction.execution
      }
    }, {
      w: 1,
      journal: true
    }, function(err, updated) {
      var updateError;
      switch (false) {
        case err == null:
          return _pushTransactionError(transaction, err, function() {
            return done(err);
          });
        case updated === 1:
          updateError = new Error("exactly one transaction must be updated when moving from " + fromStatus + " to " + toStatus + " status");
          return _pushTransactionError(transaction, updateError, function() {
            return done(updateError);
          });
        default:
          transaction.softwareVersion = _softwareVersion;
          transaction.status = toStatus;
          transaction.lastUpdatedAt = updatedAt;
          return done(null);
      }
    });
  };

  _updateTransactionState = function(transaction, done) {
    var updateOneOptions;
    updateOneOptions = _makeUpdateOptions(true, false);
    return _transactionsCollection.update({
      _id: transaction._id
    }, {
      $set: {
        'execution.state': transaction.execution.state
      }
    }, updateOneOptions, function(err, updated) {
      if ((err == null) && updated !== 1) {
        err = new Error("transaction not correctly updated with instruction state before insert");
      }
      return done(err);
    });
  };

  exports.util.updateTransactionState = _updateTransactionState;

  exports.util.updateTransactionStatus = _updateTransactionStatus;

  exports.util.pushTransactionError = _pushTransactionError;

  _mongoFlatten = function(obj) {
    var flattened, key, otherKey, otherValue, results, value, _i, _len, _ref;
    results = [];
    for (key in obj) {
      value = obj[key];
      if ((value == null) || typeof value !== 'object' || BuiltInObjects.some(function(x) {
        return value instanceof x;
      }) || MongoObjects.some(function(x) {
        return value instanceof x;
      })) {
        results.push([key, value]);
      } else {
        flattened = _mongoFlatten(value);
        for (_i = 0, _len = flattened.length; _i < _len; _i++) {
          _ref = flattened[_i], otherKey = _ref[0], otherValue = _ref[1];
          results.push(["" + key + "." + otherKey, otherValue]);
        }
      }
    }
    return results;
  };

  rollback = function(transaction, done) {
    var rollbackInstructions, rollbackLength, rollbackState;
    if (transaction.status !== 'Processing') {
      return done(new Error("can't rollback a transaction that isn't at 'Processing' status"), null);
    }
    rollbackLength = transaction.execution.results != null ? transaction.execution.results.length : transaction.instructions.length;
    rollbackInstructions = transaction.rollback.slice(0, rollbackLength);
    rollbackState = transaction.execution.state.slice(0, rollbackLength);
    rollbackInstructions.reverse();
    rollbackState.reverse();
    return execute(rollbackInstructions, rollbackState, transaction, function(rollbackErr, rollbackResults) {
      var failed, newStatus;
      failed = (rollbackErr != null) || !rollbackResults.every(function(x) {
        return x;
      });
      switch (false) {
        case !(failed && transaction.execution.errors.length > 0):
          newStatus = 'CatastropheCommitErrorRollbackError';
          break;
        case !(failed && transaction.execution.errors.length === 0):
          newStatus = 'CatastropheCommitFailedRollbackError';
          break;
        case !(!failed && transaction.execution.errors.length > 0):
          newStatus = 'FailedCommitErrorRollbackOk';
          break;
        case !(!failed && transaction.execution.errors.length === 0):
          newStatus = 'Failed';
      }
      return _updateTransactionStatus(transaction, 'Processing', newStatus, null, rollbackResults, function(statusErr) {
        if (statusErr != null) {
          return done(statusErr, transaction, newStatus);
        } else if (rollbackErr != null) {
          return _pushTransactionError(transaction, rollbackErr, function() {
            return done(rollbackErr, transaction, newStatus);
          });
        } else {
          return done(null, transaction, newStatus);
        }
      });
    });
  };

  commitWithGlobalLock = function(transaction, done) {
    return _drainQueues(['GlobalLock'], function(err) {
      if (err != null) {
        return done(err, null);
      }
      return commit(transaction, done);
    });
  };

  _requeue = function(transaction, done) {
    if (transaction.queue === 'GlobalLock') {
      return _withGlobalLock(transaction, done);
    } else {
      return _enqueue(transaction, done);
    }
  };

  _hasAfter = function(transaction) {
    return (transaction.after != null) && transaction.after.length !== 0;
  };

  _hasBefore = function(transaction) {
    return (transaction.before != null) && transaction.before.length !== 0;
  };

  _shiftChain = function(transaction) {
    var copyTransaction, key, nextTransaction, value, _results;
    nextTransaction = transaction.after.shift();
    copyTransaction = {};
    for (key in transaction) {
      value = transaction[key];
      if (key !== 'before' && key !== 'after' && key !== '_id' && key !== 'enqueuedAt') {
        copyTransaction[key] = value;
        transaction[key] = void 0;
      }
    }
    transaction.before.push(copyTransaction);
    _results = [];
    for (key in nextTransaction) {
      value = nextTransaction[key];
      if (key !== 'before' && key !== 'after' && key !== '_id' && key !== 'enqueuedAt') {
        _results.push(transaction[key] = value);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  commit = function(transactionOrFunction, done) {
    if (typeof transactionOrFunction === 'function') {
      if (transactionOrFunction.fnType === 'reader') {
        return transactionOrFunction(function() {
          var err, results;
          err = arguments[0], results = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return done.apply(null, [err, transactionOrFunction, null].concat(__slice.call(results)));
        });
      }
      if (transactionOrFunction.fnType === 'writer') {
        return transactionOrFunction(function() {
          var err, error, results, transaction, transactionOrString;
          err = arguments[0], transactionOrString = arguments[1], results = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
          if (typeof transactionOrString === 'string' || transactionOrString instanceof String || (transactionOrString == null)) {
            return done.apply(null, [err, transactionOrFunction, transactionOrString].concat(__slice.call(results)));
          } else {
            if (err != null) {
              return done(err, transactionOrString);
            }
            if (Array.isArray(transactionOrString)) {
              transaction = exports.chain(transactionOrString);
            } else {
              transaction = transactionOrString;
            }
            if (transaction.queue !== transactionOrFunction.queue) {
              return done(new Error("transaction producing function assigned to a different queue from that of the transaction it produced\n(" + transaction.queue + " isnt " + transactionOrFunction.queue + ")"), transaction);
            }
            error = _checkTransaction(transaction);
            if (error != null) {
              return done(error, transaction);
            }
            if ((transactionOrFunction.before != null) || (transactionOrFunction.after != null)) {
              if ((transaction.before != null) || (transaction.after != null)) {
                return done(new Error("a committed.writer which was part of a chain has produced a transaction object which is\nalso part of a chain, it is not clear how to act sequentially on two chains."), transaction);
              }
              transaction.before = transactionOrFunction.before;
              transaction.after = transactionOrFunction.after;
            }
            transaction.enqueuedAt = transactionOrFunction.enqueuedAt;
            return _commitCore.apply(null, [transaction].concat(__slice.call(results), [done]));
          }
        });
      }
    } else {
      return _commitCore(transactionOrFunction, done);
    }
  };

  _commitCore = function() {
    var done, transaction, writerResults, _i;
    transaction = arguments[0], writerResults = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
    if (transaction.status !== 'Queued') {
      return done(new Error("can't begin work on a transaction which isn't at 'Queued' status (" + transaction.status + ")"), null);
    }
    return _queuePosition(transaction.queue, function(err, position) {
      transaction.position = position;
      transaction.status = 'Processing';
      transaction.startedAt = new Date();
      _setUpTransaction(transaction);
      if (transaction._id == null) {
        transaction._id = _pkFactory.createPk();
      }
      return _transactionsCollection.update({
        _id: transaction._id
      }, transaction, {
        upsert: true,
        w: 1
      }, function(err, changed) {
        if ((err == null) && changed !== 1) {
          err = new Error("upsert transaction must effect exactly one document");
        }
        if (err != null) {
          return done(err, null);
        }
        return execute(transaction.instructions, transaction.execution.state, transaction, function(err, statuses, transactionResults) {
          if (err != null) {
            return _pushTransactionError(transaction, err, statuses, function() {
              return rollback(transaction, done);
            });
          } else if (statuses.length === transaction.instructions.length && statuses.every(function(x) {
            return x;
          })) {
            return _updateTransactionStatus(transaction, 'Processing', 'Committed', statuses, function(err) {
              var result, _j, _len;
              for (_j = 0, _len = transactionResults.length; _j < _len; _j++) {
                result = transactionResults[_j];
                writerResults.push(result);
              }
              return done.apply(null, [err, transaction, 'Committed'].concat(__slice.call(writerResults)));
            });
          } else {
            return _updateTransactionStatus(transaction, transaction.status, transaction.status, statuses, null, "legitimate transaction failure", function(statusErr) {
              if (err != null) {
                console.error("error saving transaction status change on legitimate failure: " + err);
              }
              return rollback(transaction, done);
            });
          }
        });
      });
    });
  };

  _makeUpdateOptions = function(onlyOne, isUpsert) {
    return {
      w: 1,
      journal: true,
      upsert: isUpsert,
      multi: !onlyOne,
      serializeFunctions: false
    };
  };

  _processRevisions = function(instructionName, config, collectionName, revisions) {
    var key, revisionName, revisionNames, revisionNumbers, _i, _len;
    if ((config.revisions == null) || (config.revisions[collectionName] == null)) {
      return [new Error("can't " + instructionName + " documents in " + collectionName + " without relevant config.revisions supplied at committed.start")];
    }
    if (revisions == null) {
      revisions = config.revisions[collectionName];
    }
    if (typeof revisions === 'string') {
      revisions = [revisions];
    }
    if (Array.isArray(revisions)) {
      revisionNames = revisions;
      revisionNumbers = null;
    } else {
      revisionNames = (function() {
        var _results;
        _results = [];
        for (key in revisions) {
          _results.push(key);
        }
        return _results;
      })();
      revisionNumbers = revisions;
    }
    for (_i = 0, _len = revisionNames.length; _i < _len; _i++) {
      revisionName = revisionNames[_i];
      if (__indexOf.call(config.revisions[collectionName], revisionName) < 0) {
        return [new Error("can't " + instructionName + " documents with a revision '" + revisionName + "' not specified in the config.revisions given at committed.start")];
      }
    }
    return [null, revisionNames, revisionNumbers];
  };

  _mongoOpsFromTo = function(mongoOps, fromDoc, toDoc) {
    var mongoMissing, path, unsetDotPaths, _i, _len;
    (function() {
      var key, value, _i, _len, _ref, _ref1, _results;
      _ref = _mongoFlatten(toDoc);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], key = _ref1[0], value = _ref1[1];
        if (key.indexOf('revision.') !== 0) {
          _results.push(mongoOps.$set[key] = value);
        }
      }
      return _results;
    })();
    mongoMissing = function(from, to) {
      var flattened, key, otherKey, results, value, _i, _len;
      results = [];
      for (key in from) {
        value = from[key];
        if (key !== void 0) {
          if ((value == null) || typeof value !== 'object' || BuiltInObjects.some(function(x) {
            return value instanceof x;
          }) || MongoObjects.some(function(x) {
            return value instanceof x;
          })) {
            if (to[key] === void 0) {
              results.push(key);
            }
          } else {
            if (to[key] === void 0) {
              results.push(key);
            } else {
              flattened = mongoMissing(value, to[key]);
              for (_i = 0, _len = flattened.length; _i < _len; _i++) {
                otherKey = flattened[_i];
                results.push("" + key + "." + otherKey);
              }
            }
          }
        }
      }
      return results;
    };
    unsetDotPaths = mongoMissing(fromDoc, toDoc);
    for (_i = 0, _len = unsetDotPaths.length; _i < _len; _i++) {
      path = unsetDotPaths[_i];
      if (path.indexOf('revision.') !== 0) {
        mongoOps.$unset[path] = 1;
      }
    }
    return delete mongoOps.$set._id;
  };

  _updateOpInstruction = function(onlyOne, isUpsert, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done) {
    var error, instructionName, revisionNames, revisionNumbers, _ref;
    instructionName = isUpsert ? 'upsert' : 'update';
    instructionName += onlyOne ? 'OneOp' : 'ManyOp';
    if (etc.length !== 0) {
      return done(new Error("too many values passed to " + instructionName));
    }
    if (!((collectionName != null) && (selector != null) && (updateOps != null))) {
      return done(new Error("null or missing argument to " + instructionName + " instruction"));
    }
    _ref = _processRevisions(instructionName, config, collectionName, revisions), error = _ref[0], revisionNames = _ref[1], revisionNumbers = _ref[2];
    if (error != null) {
      return done(error);
    }
    if (!onlyOne && (revisionNumbers != null)) {
      return done(new Error("can't " + instructionName + " with a revisions object that specifies exact revision numbers, that's only possible for singe updates"));
    }
    if ((updateOps.$inc != null) && revisionNames.some(function(name) {
      return updateOps.$inc["revision." + name];
    })) {
      return done(new Error("can't " + instructionName + " with revisions " + revisionNames + " when there are already $inc operations on the revision sub-document"));
    }
    if ((revisionNumbers != null) && revisionNames.some(function(name) {
      return selector["revision." + name];
    })) {
      return done(new Error("can't " + instructionName + " with revisions " + revisionNumbers + " with a selector that already matches on the revision subdoc"));
    }
    if ((revisionNumbers != null) && isUpsert) {
      return done(new Error("can't " + instructionName + " (upsert) when specific revision numbers " + revisionNumbers + " have been specified"));
    }
    return config.db.collection(collectionName, {
      strict: true
    }, function(err, collection) {
      var mongoProjector, mongoSelector;
      if (err != null) {
        return done(err, false);
      }
      mongoSelector = _clone(selector);
      if (rollbackProjector != null) {
        mongoProjector = _clone(rollbackProjector);
        mongoProjector._id = 1;
        mongoProjector.revision = 1;
      } else {
        mongoProjector = {};
      }
      return collection.find(mongoSelector, mongoProjector).toArray(function(err, docs) {
        if (err != null) {
          return done(err, null);
        }
        if ((onlyOne && !isUpsert && docs.length !== 1) || (isUpsert && docs.length > 1)) {
          transaction.execution.info.push("" + instructionName + " can update only one document, using " + (JSON.stringify(mongoSelector)) + " " + docs.length + " were found");
          return done(null, false);
        } else if (isUpsert && docs.length === 0) {
          if ((selector != null ? selector._id : void 0) != null) {
            state.insertedId = selector._id;
          } else {
            state.insertedId = _pkFactory.createPk();
            if (selector == null) {
              selector = {};
            }
            selector._id = state.insertedId;
          }
        } else if (onlyOne) {
          state.updated = docs[0];
        } else {
          state.updated = docs;
        }
        return _updateTransactionState(transaction, function(err) {
          var executeUpdate, matches, revisionName, revisionNumber;
          if (err != null) {
            return done(err, null);
          }
          executeUpdate = function() {
            var mongoUpdateOps, options, revisionName, _i, _len;
            options = _makeUpdateOptions(onlyOne, isUpsert);
            mongoUpdateOps = _clone(updateOps);
            if (revisionNames.length > 0) {
              if (mongoUpdateOps.$inc == null) {
                mongoUpdateOps.$inc = {};
              }
              for (_i = 0, _len = revisionNames.length; _i < _len; _i++) {
                revisionName = revisionNames[_i];
                mongoUpdateOps.$inc["revision." + revisionName] = 1;
              }
            }
            return collection.update(mongoSelector, mongoUpdateOps, options, function(err, updated) {
              if (err != null) {
                return done(err, null);
              }
              if ((onlyOne || isUpsert) && updated !== 1) {
                transaction.execution.info.push("" + instructionName + " can update only one document, using " + (JSON.stringify(mongoSelector)) + " " + updated + " were updated");
                return done(null, false);
              }
              if (onlyOne) {
                return done(null, true);
              } else {
                return done(null, true, updated);
              }
            });
          };
          if ((revisionNumbers != null) && onlyOne) {
            matches = (function() {
              var _results;
              _results = [];
              for (revisionName in revisionNumbers) {
                revisionNumber = revisionNumbers[revisionName];
                _results.push(state.updated.revision[revisionName] === revisionNumber);
              }
              return _results;
            })();
            if (!matches.every(function(x) {
              return x;
            })) {
              transaction.execution.info.push("" + instructionName + " failed to find documents to match the required revisions.\nFound: " + (JSON.stringify(state.updated)) + ".\nRequired: " + (JSON.stringify(revisionNumbers)) + ".");
              return done(null, false);
            } else {
              return executeUpdate();
            }
          } else {
            return executeUpdate();
          }
        });
      });
    });
  };

  _updateOpRollback = function(onlyOne, isUpsert, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done) {
    var error, instructionName, revisionNames, revisionNumbers, _ref;
    instructionName = onlyOne ? 'updateOneOpRollback' : 'updateManyOpRollback';
    if (etc.length !== 0) {
      return done(new Error("too many values passed to " + instructionName));
    }
    if (!((collectionName != null) && (selector != null) && (updateOps != null))) {
      return done(new Error("null or missing argument to " + instructionName + " command"));
    }
    _ref = _processRevisions(instructionName, config, collectionName, revisions), error = _ref[0], revisionNames = _ref[1], revisionNumbers = _ref[2];
    if (error != null) {
      return done(error);
    }
    return config.db.collection(collectionName, {
      strict: true
    }, function(err, collection) {
      var docs, options, rollbackDoc;
      if (err != null) {
        return done(err, false);
      }
      if ((state.updated == null) && (state.insertedId == null)) {
        return done(null, true);
      }
      if (state.insertedId != null) {
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        return collection.remove({
          _id: state.insertedId
        }, options, function(err, result) {
          return done(err);
        });
      } else {
        docs = onlyOne ? [state.updated] : state.updated;
        rollbackDoc = function(doc, rollbackDone) {
          var revisionName, revisionNumber, revisionSelector, _ref1;
          revisionSelector = {
            _id: doc._id
          };
          _ref1 = doc.revision;
          for (revisionName in _ref1) {
            revisionNumber = _ref1[revisionName];
            revisionSelector["revision." + revisionName] = revisionNumber;
          }
          return collection.count(revisionSelector, function(err, count) {
            var flattened, from, key, mongoRollbackOps, mongoSelector, op, originalDotPaths, path, renamedTo, settyOperators, to, unsetDotPaths, updateOneOptions, updatedDotPaths, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref2;
            if (count === 1) {
              return rollbackDone(null, true);
            } else if (count === 0) {
              mongoRollbackOps = {
                $set: {},
                $inc: {},
                $unset: {}
              };
              for (_i = 0, _len = revisionNames.length; _i < _len; _i++) {
                revisionName = revisionNames[_i];
                mongoRollbackOps.$inc["revision." + revisionName] = -1;
              }
              flattened = _mongoFlatten(doc);
              for (_j = 0, _len1 = flattened.length; _j < _len1; _j++) {
                _ref2 = flattened[_j], key = _ref2[0], value = _ref2[1];
                if (key.indexOf('revision.') !== 0) {
                  mongoRollbackOps.$set[key] = value;
                }
              }
              originalDotPaths = (function() {
                var _ref3, _results;
                _ref3 = mongoRollbackOps.$set;
                _results = [];
                for (key in _ref3) {
                  value = _ref3[key];
                  if (key.indexOf('revision.') !== 0) {
                    _results.push(key);
                  }
                }
                return _results;
              })();
              settyOperators = ['$inc', '$setOnInsert', '$set', '$addToSet', '$push', '$bit'];
              updatedDotPaths = [];
              for (_k = 0, _len2 = settyOperators.length; _k < _len2; _k++) {
                op = settyOperators[_k];
                if (updateOps[op] != null) {
                  for (path in updateOps[op]) {
                    updatedDotPaths.push(path);
                  }
                }
              }
              unsetDotPaths = (function() {
                var _l, _len3, _results;
                _results = [];
                for (_l = 0, _len3 = updatedDotPaths.length; _l < _len3; _l++) {
                  path = updatedDotPaths[_l];
                  if (__indexOf.call(originalDotPaths, path) < 0) {
                    _results.push(path);
                  }
                }
                return _results;
              })();
              if (updateOps['$rename'] != null) {
                renamedTo = (function() {
                  var _ref3, _results;
                  _ref3 = updateOps['$rename'];
                  _results = [];
                  for (from in _ref3) {
                    to = _ref3[from];
                    _results.push(to);
                  }
                  return _results;
                })();
                for (_l = 0, _len3 = renamedTo.length; _l < _len3; _l++) {
                  to = renamedTo[_l];
                  if (__indexOf.call(originalDotPaths, to) < 0) {
                    unsetDotPaths.push(to);
                  }
                }
              }
              for (_m = 0, _len4 = unsetDotPaths.length; _m < _len4; _m++) {
                path = unsetDotPaths[_m];
                mongoRollbackOps.$unset[path] = 1;
              }
              delete mongoRollbackOps.$set._id;
              mongoSelector = {
                _id: doc._id
              };
              updateOneOptions = _makeUpdateOptions(true, false);
              return collection.update(mongoSelector, mongoRollbackOps, options, function(err, updated) {
                if (err != null) {
                  return rollbackDone(err, false);
                }
                if (updated !== 1) {
                  transaction.execution.info.push("updateOneOpRollback failed to update exactly one document (actually " + updated + ") during rollback");
                  return rollbackDone(null, false);
                }
                return rollbackDone(null, true);
              });
            } else {
              transaction.execution.info.push("updateOneOpRollback found too many documents (" + count + ") when trying to find out if an updateOneOp had occurred\nusing selector " + (JSON.stringify(revisionSelector)));
              return rollbackDone(null, false);
            }
          });
        };
        return async.mapSeries(docs, rollbackDoc, function(err, rollbackResults) {
          if (err != null) {
            return done(err, null);
          }
          return done(err, rollbackResults.every(function(x) {
            return x;
          }));
        });
      }
    });
  };

  exports.db = {
    pass: function(config, transaction, state, args, done) {
      return done(null, true);
    },
    insert: function(config, transaction, state, _arg, done) {
      var collectionName, documents, error, etc, revisionNames, revisionNumbers, revisions, _ref;
      collectionName = _arg[0], documents = _arg[1], revisions = _arg[2], etc = 4 <= _arg.length ? __slice.call(_arg, 3) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to insert"));
      }
      if (!((collectionName != null) && (documents != null))) {
        return done(new Error("null or missing argument to insert command"));
      }
      if (!Array.isArray(documents)) {
        documents = [documents];
      }
      _ref = _processRevisions('insert', config, collectionName, revisions), error = _ref[0], revisionNames = _ref[1], revisionNumbers = _ref[2];
      if (error != null) {
        return done(error);
      }
      if (revisionNumbers != null) {
        return done(new Error("can't insert using specific revision numbers " + revisionNumbers));
      }
      if (documents.some(function(d) {
        return d.revision != null;
      })) {
        return done(new Error("can't insert documents when some already have a revision property"));
      }
      return config.db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, options, revisionName, _i, _j, _len, _len1;
        if (err != null) {
          return done(err, false);
        }
        state.ids = [];
        for (_i = 0, _len = documents.length; _i < _len; _i++) {
          d = documents[_i];
          if (d._id != null) {
            state.ids.push(d._id);
          } else {
            d._id = _pkFactory.createPk();
            state.ids.push(d._id);
          }
          if (revisionNames.length > 0 && (d.revision == null)) {
            d.revision = {};
            for (_j = 0, _len1 = revisionNames.length; _j < _len1; _j++) {
              revisionName = revisionNames[_j];
              d.revision[revisionName] = 1;
            }
          }
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        return _updateTransactionState(transaction, function(err) {
          if (err != null) {
            return done(err, null);
          }
          return collection.insert(documents, options, function(err, objects) {
            if (err != null) {
              return done(err, null);
            }
            return done(null, true);
          });
        });
      });
    },
    insertRollback: function(config, transaction, state, _arg, done) {
      var collectionName, documents, etc, revisions;
      collectionName = _arg[0], documents = _arg[1], revisions = _arg[2], etc = 4 <= _arg.length ? __slice.call(_arg, 3) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to insertRollback"));
      }
      if (!((collectionName != null) && (documents != null))) {
        return done(new Error("null or missing argument to insertRollback command"));
      }
      return config.db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, i, iterator, options, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        if (state.ids == null) {
          return done(null, true);
        } else {
          if (!Array.isArray(documents)) {
            documents = [documents];
          }
          if (documents.length !== state.ids.length) {
            return done(new Error("during rollback, number of documents to insert doesnt match the number of ids generated during insert"), false);
          }
          for (i = _i = 0, _len = documents.length; _i < _len; i = ++_i) {
            d = documents[i];
            if (d._id == null) {
              d._id = state.ids[i];
            }
          }
          iterator = function(item, itemDone) {
            return collection.remove(item, options, function(err, result) {
              return itemDone(err);
            });
          };
          return async.each(documents, iterator, function(err) {
            return done(err, true);
          });
        }
      });
    },
    updateOneOp: function(config, transaction, state, _arg, done) {
      var collectionName, etc, revisions, rollbackProjector, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackProjector = _arg[3], revisions = _arg[4], etc = 6 <= _arg.length ? __slice.call(_arg, 5) : [];
      return _updateOpInstruction(true, false, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done);
    },
    updateOneOpRollback: function(config, transaction, state, _arg, done) {
      var collectionName, etc, revisions, rollbackProjector, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackProjector = _arg[3], revisions = _arg[4], etc = 6 <= _arg.length ? __slice.call(_arg, 5) : [];
      return _updateOpRollback(true, false, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done);
    },
    upsertOneOp: function(config, transaction, state, _arg, done) {
      var collectionName, etc, revisions, rollbackProjector, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackProjector = _arg[3], revisions = _arg[4], etc = 6 <= _arg.length ? __slice.call(_arg, 5) : [];
      return _updateOpInstruction(true, true, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done);
    },
    upsertOneOpRollback: function(config, transaction, state, _arg, done) {
      var collectionName, etc, revisions, rollbackProjector, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackProjector = _arg[3], revisions = _arg[4], etc = 6 <= _arg.length ? __slice.call(_arg, 5) : [];
      return _updateOpRollback(true, true, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done);
    },
    updateManyOp: function(config, transaction, state, _arg, done) {
      var collectionName, etc, revisions, rollbackProjector, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackProjector = _arg[3], revisions = _arg[4], etc = 6 <= _arg.length ? __slice.call(_arg, 5) : [];
      return _updateOpInstruction(false, false, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done);
    },
    updateManyOpRollback: function(config, transaction, state, _arg, done) {
      var collectionName, etc, revisions, rollbackProjector, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackProjector = _arg[3], revisions = _arg[4], etc = 6 <= _arg.length ? __slice.call(_arg, 5) : [];
      return _updateOpRollback(false, false, config, transaction, state, collectionName, selector, updateOps, rollbackProjector, revisions, etc, done);
    },
    updateOneDoc: function(config, transaction, state, _arg, done) {
      var collectionName, error, etc, newPartialDocument, oldPartialDocument, revisionName, revisionNames, x, y, _ref;
      collectionName = _arg[0], newPartialDocument = _arg[1], oldPartialDocument = _arg[2], etc = 4 <= _arg.length ? __slice.call(_arg, 3) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to updateOneDoc"));
      }
      if (!((collectionName != null) && (newPartialDocument != null) && (oldPartialDocument != null))) {
        return done(new Error("null or missing argument to updateOneDoc command"));
      }
      if ((oldPartialDocument._id == null) || (newPartialDocument._id == null) || !oldPartialDocument._id.equals(newPartialDocument._id)) {
        return done(new Error("both old and new partial documents must have _ids, and they must match to updateOneDoc"));
      }
      if (oldPartialDocument.revision == null) {
        return done(new Error("oldPartialDocument must contain revision information to updateOneDoc"));
      }
      revisionNames = (function() {
        var _results;
        _results = [];
        for (revisionName in oldPartialDocument.revision) {
          _results.push(revisionName);
        }
        return _results;
      })();
      _ref = _processRevisions('updateOneDoc', config, collectionName, revisionNames), error = _ref[0], x = _ref[1], y = _ref[2];
      if (error != null) {
        return done(error);
      }
      return config.db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var key, oldSelector, value, _i, _len, _ref1, _ref2;
        if (err != null) {
          return done(err, false);
        }
        oldSelector = {};
        _ref1 = _mongoFlatten(oldPartialDocument);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], key = _ref2[0], value = _ref2[1];
          oldSelector[key] = value;
        }
        return collection.count(oldSelector, function(err, count) {
          if (err != null) {
            return done(err, false);
          }
          if (count !== 1) {
            transaction.execution.info.push("updateOneDoc failed to find exactly one document (found " + count + ") matching the given oldPartialDocument using " + (JSON.stringify(oldSelector)) + ")");
            return done(null, false);
          }
          state.safeToExecuteInstruction = true;
          return _updateTransactionState(transaction, function(err) {
            var mongoOps, selector, updateOneOptions;
            if (err != null) {
              return done(err, null);
            }
            mongoOps = {
              $set: {},
              $unset: {},
              $inc: {}
            };
            _mongoOpsFromTo(mongoOps, oldPartialDocument, newPartialDocument);
            for (revisionName in oldPartialDocument.revision) {
              mongoOps.$inc["revision." + revisionName] = 1;
            }
            updateOneOptions = _makeUpdateOptions(true, false);
            selector = {
              _id: oldPartialDocument._id
            };
            return collection.update(selector, mongoOps, updateOneOptions, function(err, updated) {
              if (err != null) {
                return done(err, null);
              }
              if (updated !== 1) {
                transaction.execution.info.push("updateOneDoc must update exactly one document, using [selector, ops] = " + (JSON.stringify([selector, mongoOps])) + " " + updated + " were updated");
                return done(null, false);
              }
              return done(null, true);
            });
          });
        });
      });
    },
    updateOneDocRollback: function(config, transaction, state, _arg, done) {
      var collectionName, etc, newPartialDocument, oldPartialDocument;
      collectionName = _arg[0], newPartialDocument = _arg[1], oldPartialDocument = _arg[2], etc = 4 <= _arg.length ? __slice.call(_arg, 3) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to updateOneDocRollback"));
      }
      if (!((collectionName != null) && (newPartialDocument != null) && (oldPartialDocument != null))) {
        return done(new Error("null or missing argument to updateOneDocRollback command"));
      }
      if ((oldPartialDocument._id == null) || (newPartialDocument._id == null) || !oldPartialDocument._id.equals(newPartialDocument._id)) {
        return done(new Error("both old and new partial documents must have _ids, and they must match to updateOneDocRollback"));
      }
      if (oldPartialDocument.revision == null) {
        return done(new Error("oldPartialDocument must contain revision information to updateOneDocRollback"));
      }
      if (!state.safeToExecuteInstruction) {
        return done(null, true);
      } else {
        return config.db.collection(collectionName, {
          strict: true
        }, function(err, collection) {
          var revisionName, selector;
          if (err != null) {
            return done(err, false);
          }
          selector = {
            _id: oldPartialDocument._id
          };
          for (revisionName in oldPartialDocument.revision) {
            selector["revision." + revisionName] = oldPartialDocument.revision[revisionName] + 1;
          }
          return collection.count(selector, function(err, count) {
            var mongoOps, updateOneOptions, updateSelector;
            if (err != null) {
              return done(err, false);
            }
            if (count === 0) {
              return done(null, true);
            } else {
              mongoOps = {
                $set: {},
                $unset: {}
              };
              _mongoOpsFromTo(mongoOps, newPartialDocument, oldPartialDocument);
              for (revisionName in oldPartialDocument.revision) {
                mongoOps.$set["revision." + revisionName] = oldPartialDocument.revision[revisionName];
              }
              updateOneOptions = _makeUpdateOptions(true, false);
              updateSelector = {
                _id: oldPartialDocument._id
              };
              return collection.update(updateSelector, mongoOps, updateOneOptions, function(err, updated) {
                if (err != null) {
                  return done(err, null);
                }
                if (updated !== 1) {
                  transaction.execution.info.push("updateOneDocRollback must update exactly one document, using [selector, ops] = " + (JSON.stringify([updateSelector, mongoOps])) + " " + updated + " were updated");
                  return done(null, false);
                }
                return done(null, true);
              });
            }
          });
        });
      }
    }
  };

  exports.transaction = function(queueName, additionalFields, instructions, rollback) {
    var key, t, value;
    t = {
      softwareVersion: _softwareVersion,
      queue: queueName,
      position: null,
      startedAt: null,
      enqueuedAt: null,
      lastUpdatedAt: null,
      status: "Queued",
      instructions: instructions != null ? instructions : [],
      rollback: rollback,
      execution: {
        state: [],
        errors: [],
        info: [],
        results: null,
        rollback: null
      }
    };
    if (additionalFields != null) {
      for (key in additionalFields) {
        value = additionalFields[key];
        t[key] = value;
      }
    }
    return t;
  };

  exports.chain = function(transactionsArg) {
    var first, t, transactions;
    if (!Array.isArray(transactionsArg)) {
      throw new Error("to chain transactions an array of transactions must be provided");
    }
    transactions = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = transactionsArg.length; _i < _len; _i++) {
        t = transactionsArg[_i];
        if (t != null) {
          _results.push(t);
        }
      }
      return _results;
    })();
    if (transactions.length === 0) {
      throw new Error("a chain can't be made from an empty array (once nulls have been removed)");
    }
    if (transactions.some(function(x) {
      return typeof x === 'function';
    })) {
      throw new Error("cannot form a chain from reader/writer functions; chains must be composed of only transaction objects");
    }
    first = transactions[0];
    first.before = [];
    first.after = transactions.slice(1);
    return first;
  };

  exports.writer = function(queueName, fn) {
    if (!typeof fn === 'function') {
      throw new Error("to create a committed.writer a function must be given as the second argument");
    }
    fn.fnType = 'writer';
    fn.queue = queueName;
    fn.status = "Queued";
    return fn;
  };

  exports.reader = function(queueName, fn) {
    if (!typeof fn === 'function') {
      throw new Error("to create a committed.reader a function must be given as the second argument");
    }
    fn.fnType = 'reader';
    fn.queue = queueName;
    fn.status = "Queued";
    return fn;
  };

}).call(this);
