// Generated by CoffeeScript 1.6.3
(function() {
  var DefaultPkFactory, ObjectID, applyToRegistered, async, commit, execute, rollback, _db, _drainQueues, _enqueueOrCreateAndEnqueue, _mongolize, _pkFactory, _pushTransactionError, _queueCountersCollection, _queuePosition, _queues, _quietly, _registry, _revisionedUpdateChecks, _softwareVersion, _state, _transactionsCollection, _updateOneOptions, _updateTransactionStatus,
    __slice = [].slice;

  async = require('async');

  ObjectID = require('mongodb').ObjectID;

  _state = 'stopped';

  _queues = null;

  _db = null;

  _registry = {};

  _softwareVersion = null;

  _queueCountersCollection = null;

  _transactionsCollection = null;

  _pkFactory = null;

  DefaultPkFactory = (function() {
    function DefaultPkFactory() {}

    DefaultPkFactory.prototype.createPk = function() {
      return new ObjectID();
    };

    return DefaultPkFactory;

  })();

  exports.start = function() {
    var db, done, optionals, tasks, _i;
    db = arguments[0], optionals = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
    if (_state !== 'stopped') {
      return done(new Error("committed has already been started"));
    }
    _softwareVersion = optionals[0];
    _pkFactory = optionals[1] != null ? new optionals[1]() : new DefaultPkFactory();
    _db = db;
    tasks = [];
    tasks.push(function(done) {
      return _db.createCollection('transactions', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _transactionsCollection = collection;
        return _db.ensureIndex('transactions', {
          status: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _db.createCollection('queueCounters', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _queueCountersCollection = collection;
        return _db.ensureIndex('queueCounters', {
          queue: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _transactionsCollection.find({
        status: 'Processing'
      }, {
        snapshot: true
      }).sort('position', 1, function(err, transactions) {
        if (err != null) {
          return done(err, null);
        }
        return async.eachSeries(transactions, _quietly(rollback), done);
      });
    });
    tasks.push(function(done) {
      return _transactionsCollection.find({
        status: 'Queued'
      }, {
        snapshot: true
      }).sort('position', 1, function(err, transactions) {
        return async.eachSeries(transactions, _quietly(commit), done);
      });
    });
    return async.series(tasks, function(err, results) {
      if (err != null) {
        return done(err);
      }
      _queues = {
        GlobalLock: async.queue(commit, 1)
      };
      _queues.GlobalLock.drain = function() {
        return _state = 'started';
      };
      _state = 'started';
      return done(null);
    });
  };

  exports.stop = function(done) {
    var name;
    if (_state !== 'started') {
      return done(new Error("committed is not currently started"));
    }
    _state = 'stopped';
    return _drainQueues((function() {
      var _results;
      _results = [];
      for (name in _queues) {
        _results.push(name);
      }
      return _results;
    })(), done);
  };

  _drainQueues = function(queues, done) {
    var name, tasks, _fn, _i, _len;
    tasks = [];
    _fn = function(name) {
      return tasks.push(function(done) {
        if (_queues[name].length() === 0) {
          return done(null, null);
        } else {
          return _queues[name].drain = function() {
            return done(null, null);
          };
        }
      });
    };
    for (_i = 0, _len = queues.length; _i < _len; _i++) {
      name = queues[_i];
      _fn(name);
    }
    return async.parallel(tasks, function(err, results) {
      var _j, _len1;
      for (_j = 0, _len1 = queues.length; _j < _len1; _j++) {
        name = queues[_j];
        _queues[name].drain = void 0;
      }
      return done(err);
    });
  };

  exports.register = function(name, fnOrObj) {
    var ancestor, ancestors, key, parent, _i, _len;
    parent = _registry;
    ancestors = name.split('.');
    key = ancestors.pop();
    for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
      ancestor = ancestors[_i];
      parent = parent[ancestor];
      if (parent == null) {
        throw new Error("during register: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry)));
      }
    }
    if (parent[key] != null) {
      throw new Error("during register: path " + name + " already exists in registry: " + (JSON.stringify(_registry)));
    }
    return parent[key] = fnOrObj;
  };

  _queuePosition = function(queueName, done) {
    return _queueCountersCollection.findAndModify({
      queue: queueName
    }, {}, {
      $inc: {
        nextPosition: 1
      }
    }, {
      upsert: true,
      w: 1,
      journal: true
    }, function(err, doc) {
      var _ref;
      if (err != null) {
        return done(err, null);
      }
      return done(null, (_ref = doc.nextPosition) != null ? _ref : 0);
    });
  };

  _enqueueOrCreateAndEnqueue = function(queueName, transaction, done) {
    if (_queues[queueName] == null) {
      _queues[queueName] = async.queue(commit, 1);
    }
    return _queues[queueName].push(transaction, done);
  };

  exports.enqueue = function(transaction, done) {
    var enqueue, _ref;
    transaction.enqueuedAt = new Date();
    enqueue = function() {
      if (_state === 'started') {
        return _enqueueOrCreateAndEnqueue(transaction.queue, transaction, done);
      } else {
        return _updateTransactionStatus(transaction, transaction.status, 'Failed', function(err) {
          return done(err, 'Failed');
        });
      }
    };
    if (transaction.queue === "GlobalLock") {
      return done(new Error("Can't queue a transaction for GlobalLock using the committed.enqueue function"), null);
    }
    if (!((_ref = transaction.queue) != null ? _ref.length : void 0)) {
      return done(new Error("must have a transaction.queue parameter to use committed.enqueue"), null);
    }
    if ((transaction.status != null) && transaction.status !== 'Queued') {
      return done(new Error("Can't queue a transaction which is at a status other than Queued (or null)"));
    }
    return setImmediate(function() {
      transaction.status = _state === 'started' ? "Queued" : "Failed";
      return _queuePosition(transaction.queue, function(err, position) {
        transaction.position = position;
        return _transactionsCollection.insert(transaction, function(err, docs) {
          if (err != null) {
            return done(err, null);
          }
          return enqueue();
        });
      });
    });
  };

  exports.immediately = function(transaction, done) {
    var go;
    transaction.enqueuedAt = new Date();
    go = function() {
      if (_state === 'started') {
        return commit(transaction, done);
      } else {
        return _updateTransactionStatus(transaction, transaction.status, 'Failed', function(err) {
          return done(err, 'Failed');
        });
      }
    };
    if (transaction.queue != null) {
      return done(new Error("Can't call committed.immediately on a transaction which has a queue defined for it"));
    }
    if ((transaction.status != null) && transaction.status !== 'Queued') {
      return done(new Error("Can't queue a transaction which is at a status other than Queued (or null)"));
    }
    return setImmediate(function() {
      transaction.status = _state === 'started' ? "Queued" : "Failed";
      transaction.position = -1;
      return _transactionsCollection.insert(transaction, function(err, docs) {
        if (err != null) {
          return done(err, null);
        }
        return go();
      });
    });
  };

  exports.withGlobalLock = function(transaction, done) {
    var enqueue;
    if (transaction.queue !== "GlobalLock") {
      return done(new Error("Can't call committed.withGlobalLock for a transaction that names a queue other than 'GlobalLock'"), null);
    }
    if ((transaction.status != null) && transaction.status !== 'Queued') {
      return done(new Error("Can't queue a transaction which is at a status other than Queued (or null)"));
    }
    transaction.enqueuedAt = new Date();
    enqueue = function() {
      var name;
      return _drainQueues((function() {
        var _results;
        _results = [];
        for (name in _queues) {
          if (name !== 'GlobalLock') {
            _results.push(name);
          }
        }
        return _results;
      })(), function(err) {
        if (err != null) {
          return done(err, null);
        }
        return _queues['GlobalLock'].push(transaction, done);
      });
    };
    transaction.status = _state !== 'stopped' ? "Queued" : "Failed";
    return _queuePosition(transaction.queue, function(err, position) {
      var oldState;
      transaction.position = position;
      if (_state !== 'stopped') {
        oldState = _state;
        _state = 'locked';
      }
      return _transactionsCollection.insert(transaction, function(err, docs) {
        if (err != null) {
          _state = oldState;
          return done(err, null);
        }
        if (_state === 'stopped') {
          return done(null, 'Failed');
        } else {
          return enqueue();
        }
      });
    });
  };

  applyToRegistered = function(name, fnArgs) {
    var done, found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        done = fnArgs[fnArgs.length - 1];
        return done(new Error("during applyToRegistered: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry))));
      }
    }
    return found.apply(this, fnArgs);
  };

  execute = function(instructions, data, done) {
    var iterator, result;
    result = true;
    iterator = function(instruction, iteratorDone) {
      var fnArgs;
      fnArgs = [_db, data];
      if (instruction["arguments"] != null) {
        fnArgs = fnArgs.concat(instruction["arguments"]);
      }
      fnArgs.push(function(err, iteratorResult) {
        if (iteratorResult === false) {
          result = false;
        }
        return iteratorDone(err);
      });
      return applyToRegistered(instruction.name, fnArgs);
    };
    return async.each(instructions, iterator, function(err) {
      return done(err, result);
    });
  };

  _quietly = function(fn) {
    return function() {
      var args, done, quietDone, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
      quietDone = function(err, result) {
        if (err != null) {
          console.log("error suppressed, probably during committed.start: " + err);
        }
        return done(null, result);
      };
      return fn.apply(null, __slice.call(args).concat([quietDone]));
    };
  };

  _pushTransactionError = function(transaction, error, done) {
    var serialisedError;
    if ((error.name != null) && (error.stack != null) && (error.message != null)) {
      serialisedError = {
        name: error.name,
        message: error.message,
        stack: error.stack
      };
    } else {
      serialisedError = error.toString();
    }
    transaction.errors.push(serialisedError);
    return _transactionsCollection.update({
      _id: transaction._id
    }, {
      $push: {
        errors: serialisedError
      }
    }, {
      w: 1,
      journal: true
    }, function(err, updated) {
      if (err != null) {
        console.log("error saving error to transaction: " + err);
      }
      return done();
    });
  };

  _updateTransactionStatus = function(transaction, fromStatus, toStatus, done) {
    return _transactionsCollection.update({
      _id: transaction._id,
      status: fromStatus
    }, {
      $set: {
        status: toStatus,
        softwareVersion: _softwareVersion,
        enqueuedAt: transaction.enqueuedAt,
        startedAt: transaction.startedAt
      }
    }, {
      w: 1,
      journal: true
    }, function(err, updated) {
      var updateError;
      switch (false) {
        case err == null:
          return _pushTransactionError(transaction, err, function() {
            return done(err);
          });
        case updated === 1:
          updateError = new Error('exactly one transaction must be updated when moving to Processing status');
          return _pushTransactionError(transaction, updateError, function() {
            return done(updateError);
          });
        default:
          transaction.softwareVersion = _softwareVersion;
          transaction.status = toStatus;
          return done(null);
      }
    });
  };

  rollback = function(transaction, failStatus, done) {
    if (transaction.status !== 'Processing') {
      return done(new Error("can't rollback a transaction that isn't at 'Processing' status"), null);
    }
    return execute(transaction.rollback, transaction.data, function(rollbackErr, result) {
      var failed, newStatus;
      failed = (rollbackErr != null) || result === false;
      switch (false) {
        case !(failed && transaction.errors.length > 0):
          newStatus = 'CatastropheCommitErrorRollbackError';
          break;
        case !(failed && transaction.errors.length === 0):
          newStatus = 'CatastropheCommitFailedRollbackError';
          break;
        case !(!failed && transaction.errors.length > 0):
          newStatus = 'FailedCommitErrorRollbackOk';
          break;
        case !(!failed && transaction.errors.length === 0):
          newStatus = 'Failed';
      }
      return _updateTransactionStatus(transaction, 'Processing', newStatus, function(statusErr) {
        if (statusErr != null) {
          return done(statusErr, newStatus);
        } else if (rollbackErr != null) {
          return _pushTransactionError(transaction, rollbackErr, function() {
            return done(rollbackErr, newStatus);
          });
        } else {
          return done(null, newStatus);
        }
      });
    });
  };

  commit = function(transaction, done) {
    var doCommit;
    doCommit = function(err) {
      if (err != null) {
        return done(err, null);
      }
      return execute(transaction.instructions, transaction.data, function(err, result) {
        if (err != null) {
          return _pushTransactionError(transaction, err, function() {
            return rollback(transaction, err, done);
          });
        } else if (result) {
          return _updateTransactionStatus(transaction, 'Processing', 'Committed', function(err) {
            return done(err, 'Committed');
          });
        } else {
          return rollback(transaction, err, done);
        }
      });
    };
    if (transaction.status !== 'Queued') {
      return done(new Error("can't begin work on a transaction which isn't at 'Queued' status (" + transaction.status + ")"), null);
    }
    transaction.status = 'Processing';
    transaction.startedAt = new Date();
    return _updateTransactionStatus(transaction, 'Queued', 'Processing', doCommit);
  };

  _mongolize = function(operations) {
    var key, mongoOps, value;
    if (Array.isArray(operations)) {
      return operations;
    }
    if (typeof operations === 'object') {
      mongoOps = {};
      for (key in operations) {
        value = operations[key];
        if (key.indexOf('__') === 0) {
          mongoOps['$' + key.slice(2)] = _mongolize(value);
        } else {
          mongoOps[key] = _mongolize(value);
        }
      }
      return mongoOps;
    } else {
      return operations;
    }
  };

  _updateOneOptions = {
    w: 1,
    journal: true,
    upsert: false,
    multi: false,
    serializeFunctions: false
  };

  _revisionedUpdateChecks = function(revisionName, newPartialDocument, oldPartialDocument) {
    if (!((newPartialDocument.revision != null) && (newPartialDocument.revision[revisionName] != null) && (newPartialDocument._id != null))) {
      return new Error("unable to do a revisioned update with a newPartialDocument which does not contain the specified revision key (" + revisionName + "), or is missing _id");
    }
    if (!((oldPartialDocument.revision != null) && (oldPartialDocument.revision[revisionName] != null) && (oldPartialDocument._id != null))) {
      return new Error("unable to do a revisioned update with a oldPartialDocument which does not contain the specified revision key (" + revisionName + "), or is missing _id");
    }
    if (oldPartialDocument.revision[revisionName] !== newPartialDocument.revision[revisionName]) {
      return new Error("revision numbers between old and newPartialDocument must match (" + oldPartialDocument.revision[revisionName] + " isnt " + newPartialDocument.revision[revisionName]);
    }
    if (typeof oldPartialDocument.revision[revisionName] !== 'number') {
      return new Error("unable to do a revisioned update, revision." + revisionName + " isn't of type number");
    }
    return null;
  };

  exports.db = {
    updateOne: function(db, transactionData, collectionName, selector, values, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, false);
        }
        return collection.update(selector, values, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneField: function(db, transactionData, collectionName, selector, field, value, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var setter;
        if (err != null) {
          return done(err, false);
        }
        setter = {};
        setter[field] = value;
        return collection.update(selector, {
          $set: setter
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneFields: function(db, transactionData, collectionName, selector, fieldValues, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fieldValue, setter, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        setter = {};
        for (_i = 0, _len = fieldValues.length; _i < _len; _i++) {
          fieldValue = fieldValues[_i];
          setter[fieldValue.field] = fieldValue.value;
        }
        return collection.update(selector, {
          $set: setter
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    insert: function(db, transactionData, collectionName, documents, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, options, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        if (documents.length == null) {
          documents = [documents];
        }
        for (_i = 0, _len = documents.length; _i < _len; _i++) {
          d = documents[_i];
          if (d._id == null) {
            d._id = _pkFactory.createPk();
          }
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        return collection.insert(documents, options, function(err, objects) {
          if (err != null) {
            return done(err, null);
          }
          return done(null, true);
        });
      });
    },
    insertRollback: function(db, transactionData, collectionName, documents, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var iterator, options;
        if (err != null) {
          return done(err, false);
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        if (documents.length == null) {
          documents = [documents];
        }
        iterator = function(item, itemDone) {
          if (item._id == null) {
            return itemDone(new Error("unable to rollback an insert of document which doesn't have an _id field, this could be unsafe"));
          }
          return collection.remove(item, options, function(err, result) {
            return itemDone(err);
          });
        };
        return async.each(documents, iterator, function(err) {
          return done(err, true);
        });
      });
    },
    updateOneOp: function(db, transactionData, collectionName, selector, updateOps, rollbackOps, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, false);
        }
        return collection.update(_mongolize(selector), _mongolize(updateOps), _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneOpRollback: function(db, transactionData, collectionName, selector, updateOps, rollbackOps, done) {
      return exports.db.updateOneOp(db, transactionData, collectionName, selector, rollbackOps, {}, done);
    },
    revisionedUpdate: function(db, transactionData, collectionName, revisionName, newPartialDocument, oldPartialDocument, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fail, fields, key, mongoOps, mongoSelector, revisionKey, value;
        if (err != null) {
          return done(err, false);
        }
        fail = _revisionedUpdateChecks(revisionName, newPartialDocument, oldPartialDocument);
        if (fail != null) {
          return done(fail);
        }
        revisionKey = "revision." + revisionName;
        mongoSelector = {
          _id: newPartialDocument._id
        };
        mongoSelector[revisionKey] = oldPartialDocument.revision[revisionName];
        fields = {};
        for (key in newPartialDocument) {
          value = newPartialDocument[key];
          if (key !== 'revision' && key !== '_id') {
            fields[key] = value;
          }
        }
        mongoOps = {
          $set: fields,
          $inc: {}
        };
        mongoOps.$inc[revisionKey] = 1;
        return collection.update(mongoSelector, mongoOps, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    revisionedUpdateRollback: function(db, transactionData, collectionName, revisionName, newPartialDocument, oldPartialDocument, done) {
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fail, key, newFields, oldFields, revisionKey, value;
        if (err != null) {
          return done(err, false);
        }
        fail = _revisionedUpdateChecks(revisionName, newPartialDocument, oldPartialDocument);
        if (fail != null) {
          return done(fail);
        }
        revisionKey = "revision." + revisionName;
        oldFields = {};
        oldFields[revisionKey] = oldPartialDocument.revision[revisionName];
        for (key in oldPartialDocument) {
          value = oldPartialDocument[key];
          if (key !== 'revision' && key !== '_id') {
            oldFields[key] = value;
          }
        }
        newFields = {};
        newFields[revisionKey] = newPartialDocument.revision[revisionName] + 1;
        for (key in newPartialDocument) {
          value = newPartialDocument[key];
          if (key !== 'revision') {
            newFields[key] = value;
          }
        }
        return collection.update(newFields, {
          $set: oldFields
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          return done(null, true);
        });
      });
    }
  };

  exports.transaction = function(queueName, username) {
    var transaction;
    return transaction = {
      softwareVersion: _softwareVersion,
      queue: queueName,
      position: 1,
      startedAt: null,
      enqueuedAt: null,
      enqueuedBy: username,
      status: "Queued",
      errors: [],
      data: {},
      instructions: [],
      rollback: []
    };
  };

}).call(this);
