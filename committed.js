// Generated by CoffeeScript 1.6.3
(function() {
  var DefaultPkFactory, ObjectID, applyToRegistered, async, commit, execute, rollback, _checkTransaction, _clone, _db, _drainQueues, _enqueueOrCreateAndEnqueue, _instructionsExistFor, _mongolize, _pkFactory, _pushTransactionError, _queueCountersCollection, _queuePosition, _queues, _quietly, _registry, _registryFind, _revisionedUpdateChecks, _setUpTransaction, _softwareVersion, _state, _transactionsCollection, _updateOneOptions, _updateTransactionState, _updateTransactionStatus,
    __slice = [].slice;

  async = require('async');

  ObjectID = require('mongodb').ObjectID;

  _state = 'stopped';

  _queues = null;

  _db = null;

  _registry = {};

  _softwareVersion = null;

  _queueCountersCollection = null;

  _transactionsCollection = null;

  _pkFactory = null;

  DefaultPkFactory = (function() {
    function DefaultPkFactory() {}

    DefaultPkFactory.prototype.createPk = function() {
      return new ObjectID();
    };

    return DefaultPkFactory;

  })();

  exports.start = function() {
    var db, done, optionals, tasks, _i;
    db = arguments[0], optionals = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
    if (_state !== 'stopped') {
      return done(new Error("committed has already been started"));
    }
    _softwareVersion = optionals[0];
    _pkFactory = optionals[1] != null ? new optionals[1]() : new DefaultPkFactory();
    _db = db;
    tasks = [];
    tasks.push(function(done) {
      return _db.createCollection('transactions', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _transactionsCollection = collection;
        return _db.ensureIndex('transactions', {
          status: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _db.createCollection('queueCounters', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _queueCountersCollection = collection;
        return _db.ensureIndex('queueCounters', {
          queue: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _transactionsCollection.find({
        status: 'Processing'
      }, {
        snapshot: true
      }).sort('position', 1, function(err, transactions) {
        if (err != null) {
          return done(err, null);
        }
        return async.eachSeries(transactions, _quietly(rollback), done);
      });
    });
    tasks.push(function(done) {
      return _transactionsCollection.find({
        status: 'Queued'
      }, {
        snapshot: true
      }).sort('position', 1, function(err, transactions) {
        return async.eachSeries(transactions, _quietly(commit), done);
      });
    });
    return async.series(tasks, function(err, results) {
      if (err != null) {
        return done(err);
      }
      _queues = {
        GlobalLock: async.queue(commit, 1)
      };
      _queues.GlobalLock.drain = function() {
        return _state = 'started';
      };
      _state = 'started';
      return done(null);
    });
  };

  exports.stop = function(done) {
    var name;
    if (_state !== 'started') {
      return done(new Error("committed is not currently started"));
    }
    _state = 'stopped';
    return _drainQueues((function() {
      var _results;
      _results = [];
      for (name in _queues) {
        _results.push(name);
      }
      return _results;
    })(), done);
  };

  _drainQueues = function(queues, done) {
    var name, tasks, _fn, _i, _len;
    tasks = [];
    _fn = function(name) {
      return tasks.push(function(done) {
        if (_queues[name].length() === 0) {
          return done(null, null);
        } else {
          return _queues[name].drain = function() {
            return done(null, null);
          };
        }
      });
    };
    for (_i = 0, _len = queues.length; _i < _len; _i++) {
      name = queues[_i];
      _fn(name);
    }
    return async.parallel(tasks, function(err, results) {
      var _j, _len1;
      for (_j = 0, _len1 = queues.length; _j < _len1; _j++) {
        name = queues[_j];
        _queues[name].drain = void 0;
      }
      return done(err);
    });
  };

  exports.register = function(name, fnOrObj) {
    var ancestor, ancestors, key, parent, _i, _len;
    parent = _registry;
    ancestors = name.split('.');
    key = ancestors.pop();
    for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
      ancestor = ancestors[_i];
      parent = parent[ancestor];
      if (parent == null) {
        throw new Error("during register: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry)));
      }
    }
    if (parent[key] != null) {
      throw new Error("during register: path " + name + " already exists in registry: " + (JSON.stringify(_registry)));
    }
    return parent[key] = fnOrObj;
  };

  _queuePosition = function(queueName, done) {
    return _queueCountersCollection.findAndModify({
      queue: queueName
    }, {}, {
      $inc: {
        nextPosition: 1
      }
    }, {
      upsert: true,
      w: 1,
      journal: true
    }, function(err, doc) {
      var _ref;
      if (err != null) {
        return done(err, null);
      }
      return done(null, (_ref = doc.nextPosition) != null ? _ref : 0);
    });
  };

  _enqueueOrCreateAndEnqueue = function(queueName, transaction, done) {
    if (_queues[queueName] == null) {
      _queues[queueName] = async.queue(commit, 1);
    }
    return _queues[queueName].push(transaction, done);
  };

  _checkTransaction = function(transaction) {
    if ((transaction.status != null) && transaction.status !== 'Queued') {
      return new Error("Can't queue a transaction which is at a status other than Queued (or null)");
    }
    if (!_instructionsExistFor(transaction)) {
      return new Error("Can't queue a transaction for which either its instructions, rollback instructions, or implied auto rollback instructions don't exist in the registry");
    }
    if ((transaction.rollback != null) && transaction.rollback.length !== transaction.instructions.length) {
      return new Error("Can't queue a transaction with an explicit rollback instructions whose length is not the same as its instructions array");
    }
  };

  _instructionsExistFor = function(transaction) {
    var i, _i, _j, _len, _len1, _ref, _ref1;
    if (transaction.rollback != null) {
      _ref = transaction.instructions.concat(transaction.rollback);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (_registryFind(i.name) == null) {
          return false;
        }
      }
    } else {
      _ref1 = transaction.instructions;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        i = _ref1[_j];
        if (_registryFind(i.name) == null) {
          return false;
        }
        if (_registryFind(i.name + 'Rollback') == null) {
          return false;
        }
      }
    }
    return true;
  };

  _setUpTransaction = function(transaction) {
    var i, iRoll, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (transaction.rollback == null) {
      transaction.rollback = [];
      _ref = transaction.instructions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        iRoll = _clone(i);
        iRoll.name = iRoll.name + 'Rollback';
        transaction.rollback.push(iRoll);
      }
    }
    transaction.execution.state = [];
    _ref1 = transaction.instructions;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      i = _ref1[_j];
      _results.push(transaction.execution.state.push({}));
    }
    return _results;
  };

  exports.enqueue = function(transaction, done) {
    var enqueue, error, _ref;
    transaction.enqueuedAt = new Date();
    enqueue = function() {
      if (_state === 'started') {
        return _enqueueOrCreateAndEnqueue(transaction.queue, transaction, done);
      } else {
        return _updateTransactionStatus(transaction, transaction.status, 'Failed', function(err) {
          return done(err, 'Failed');
        });
      }
    };
    if (transaction.queue === "GlobalLock") {
      return done(new Error("Can't queue a transaction for GlobalLock using the committed.enqueue function"), null);
    }
    if (!((_ref = transaction.queue) != null ? _ref.length : void 0)) {
      return done(new Error("must have a transaction.queue parameter to use committed.enqueue"), null);
    }
    error = _checkTransaction(transaction);
    if (error != null) {
      return done(error, null);
    }
    return setImmediate(function() {
      transaction.status = _state === 'started' ? "Queued" : "Failed";
      return _queuePosition(transaction.queue, function(err, position) {
        transaction.position = position;
        _setUpTransaction(transaction);
        return _transactionsCollection.insert(transaction, function(err, docs) {
          if (err != null) {
            return done(err, null);
          }
          return enqueue();
        });
      });
    });
  };

  exports.immediately = function(transaction, done) {
    var error, go;
    transaction.enqueuedAt = new Date();
    go = function() {
      if (_state === 'started') {
        return commit(transaction, done);
      } else {
        return _updateTransactionStatus(transaction, transaction.status, 'Failed', function(err) {
          return done(err, 'Failed');
        });
      }
    };
    if (transaction.queue != null) {
      return done(new Error("Can't call committed.immediately on a transaction which has a queue defined for it"));
    }
    error = _checkTransaction(transaction);
    if (error != null) {
      return done(error, null);
    }
    return setImmediate(function() {
      transaction.status = _state === 'started' ? "Queued" : "Failed";
      transaction.position = -1;
      _setUpTransaction(transaction);
      return _transactionsCollection.insert(transaction, function(err, docs) {
        if (err != null) {
          return done(err, null);
        }
        return go();
      });
    });
  };

  exports.withGlobalLock = function(transaction, done) {
    var enqueue, error;
    if (transaction.queue !== "GlobalLock") {
      return done(new Error("Can't call committed.withGlobalLock for a transaction that names a queue other than 'GlobalLock'"), null);
    }
    error = _checkTransaction(transaction);
    if (error != null) {
      return done(error, null);
    }
    transaction.enqueuedAt = new Date();
    enqueue = function() {
      var name;
      return _drainQueues((function() {
        var _results;
        _results = [];
        for (name in _queues) {
          if (name !== 'GlobalLock') {
            _results.push(name);
          }
        }
        return _results;
      })(), function(err) {
        if (err != null) {
          return done(err, null);
        }
        return _queues['GlobalLock'].push(transaction, done);
      });
    };
    transaction.status = _state !== 'stopped' ? "Queued" : "Failed";
    return _queuePosition(transaction.queue, function(err, position) {
      var oldState;
      transaction.position = position;
      _setUpTransaction(transaction);
      if (_state !== 'stopped') {
        oldState = _state;
        _state = 'locked';
      }
      return _transactionsCollection.insert(transaction, function(err, docs) {
        if (err != null) {
          _state = oldState;
          return done(err, null);
        }
        if (_state === 'stopped') {
          return done(null, 'Failed');
        } else {
          return enqueue();
        }
      });
    });
  };

  _registryFind = function(name) {
    var found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        return null;
      }
    }
    return found;
  };

  applyToRegistered = function(name, fnArgs) {
    var done, found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        done = fnArgs[fnArgs.length - 1];
        return done(new Error("during applyToRegistered: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry))));
      }
    }
    return found.apply(this, fnArgs);
  };

  execute = function(instructions, state, transaction, done) {
    var i, instruction, instructionsWithState, iterator, results;
    results = [];
    iterator = function(_arg, iteratorDone) {
      var args, fnArgs, instruction, state;
      instruction = _arg[0], state = _arg[1];
      args = instruction["arguments"] != null ? instruction["arguments"] : [];
      if (!Array.isArray(args)) {
        args = [args];
      }
      fnArgs = [_db, transaction, state, args];
      fnArgs.push(function(err, iteratorResult) {
        if ((err == null) && iteratorResult === false) {
          err = 'instructionFailed';
        }
        results.push(iteratorResult);
        return iteratorDone(err);
      });
      return applyToRegistered(instruction.name, fnArgs);
    };
    instructionsWithState = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = instructions.length; _i < _len; i = ++_i) {
        instruction = instructions[i];
        _results.push([instruction, state[i]]);
      }
      return _results;
    })();
    return async.eachSeries(instructionsWithState, iterator, function(err) {
      if (err === 'instructionFailed') {
        err = null;
      }
      return done(err, results);
    });
  };

  _quietly = function(fn) {
    return function() {
      var args, done, quietDone, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
      quietDone = function(err, result) {
        if (err != null) {
          console.log("error suppressed, probably during committed.start: " + err);
        }
        return done(null, result);
      };
      return fn.apply(null, __slice.call(args).concat([quietDone]));
    };
  };

  _pushTransactionError = function(transaction, error, done) {
    var serialisedError;
    if ((error.name != null) && (error.stack != null) && (error.message != null)) {
      serialisedError = {
        name: error.name,
        message: error.message,
        stack: error.stack
      };
    } else {
      serialisedError = error.toString();
    }
    transaction.execution.errors.push(serialisedError);
    return _transactionsCollection.update({
      _id: transaction._id
    }, {
      $push: {
        'execution.errors': serialisedError
      }
    }, {
      w: 1,
      journal: true
    }, function(err, updated) {
      if (err != null) {
        console.log("error saving error to transaction: " + err);
      }
      return done();
    });
  };

  _updateTransactionStatus = function(transaction, fromStatus, toStatus, done) {
    return _transactionsCollection.update({
      _id: transaction._id,
      status: fromStatus
    }, {
      $set: {
        status: toStatus,
        softwareVersion: _softwareVersion,
        enqueuedAt: transaction.enqueuedAt,
        startedAt: transaction.startedAt,
        lastUpdatedAt: new Date()
      }
    }, {
      w: 1,
      journal: true
    }, function(err, updated) {
      var updateError;
      switch (false) {
        case err == null:
          return _pushTransactionError(transaction, err, function() {
            return done(err);
          });
        case updated === 1:
          updateError = new Error('exactly one transaction must be updated when moving to Processing status');
          return _pushTransactionError(transaction, updateError, function() {
            return done(updateError);
          });
        default:
          transaction.softwareVersion = _softwareVersion;
          transaction.status = toStatus;
          return done(null);
      }
    });
  };

  _updateTransactionState = function(transaction, done) {
    return _transactionsCollection.update({
      _id: transaction._id
    }, {
      $set: {
        'executions.state': transaction.execution.state
      }
    }, _updateOneOptions, function(err, updated) {
      if ((err == null) && updated !== 1) {
        err = new Error("transaction not correctly updated with instruction state before insert");
      }
      return done(err);
    });
  };

  _clone = function(obj, mongolize) {
    var flags, key, newInstance, value, x;
    if (mongolize == null) {
      mongolize = false;
    }
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Array) {
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          x = obj[_i];
          _results.push(_clone(x, mongolize));
        }
        return _results;
      })();
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      value = obj[key];
      if (mongolize && key.indexOf('__') === 0) {
        newInstance['$' + key.slice(2)] = _clone(value, mongolize);
      } else {
        newInstance[key] = _clone(value, mongolize);
      }
    }
    return newInstance;
  };

  _mongolize = function(obj) {
    return _clone(obj, true);
  };

  rollback = function(transaction, results, done) {
    var rollbackInstructions, rollbackState;
    if (transaction.status !== 'Processing') {
      return done(new Error("can't rollback a transaction that isn't at 'Processing' status"), null);
    }
    rollbackInstructions = transaction.rollback.slice(0, results.length);
    rollbackState = transaction.execution.state.slice(0, results.length);
    rollbackInstructions.reverse();
    rollbackState.reverse();
    return execute(rollbackInstructions, rollbackState, transaction, function(rollbackErr, results) {
      var failed, newStatus;
      failed = (rollbackErr != null) || !results.every(function(x) {
        return x;
      });
      switch (false) {
        case !(failed && transaction.execution.errors.length > 0):
          newStatus = 'CatastropheCommitErrorRollbackError';
          break;
        case !(failed && transaction.execution.errors.length === 0):
          newStatus = 'CatastropheCommitFailedRollbackError';
          break;
        case !(!failed && transaction.execution.errors.length > 0):
          newStatus = 'FailedCommitErrorRollbackOk';
          break;
        case !(!failed && transaction.execution.errors.length === 0):
          newStatus = 'Failed';
      }
      return _updateTransactionStatus(transaction, 'Processing', newStatus, function(statusErr) {
        if (statusErr != null) {
          return done(statusErr, newStatus);
        } else if (rollbackErr != null) {
          return _pushTransactionError(transaction, rollbackErr, function() {
            return done(rollbackErr, newStatus);
          });
        } else {
          return done(null, newStatus);
        }
      });
    });
  };

  commit = function(transaction, done) {
    var doCommit;
    doCommit = function(err) {
      if (err != null) {
        return done(err, null);
      }
      return execute(transaction.instructions, transaction.execution.state, transaction, function(err, results) {
        var failureInfo;
        if (err != null) {
          return _pushTransactionError(transaction, err, function() {
            return rollback(transaction, results, done);
          });
        } else if (results.length === transaction.instructions.length && results.every(function(x) {
          return x;
        })) {
          return _updateTransactionStatus(transaction, 'Processing', 'Committed', function(err) {
            return done(err, 'Committed');
          });
        } else {
          failureInfo = "legitimate transaction failure, instruction results: " + (JSON.stringify(results));
          transaction.execution.info.push(failureInfo);
          return _transactionsCollection.update({
            _id: transaction._id
          }, {
            $push: {
              'execution.info': failureInfo
            }
          }, {
            w: 1,
            journal: true
          }, function(err, updated) {
            if (err != null) {
              console.log("error saving error to transaction: " + err);
            }
            return rollback(transaction, results, done);
          });
        }
      });
    };
    if (transaction.status !== 'Queued') {
      return done(new Error("can't begin work on a transaction which isn't at 'Queued' status (" + transaction.status + ")"), null);
    }
    transaction.status = 'Processing';
    transaction.startedAt = new Date();
    return _updateTransactionStatus(transaction, 'Queued', 'Processing', doCommit);
  };

  _updateOneOptions = {
    w: 1,
    journal: true,
    upsert: false,
    multi: false,
    serializeFunctions: false
  };

  _revisionedUpdateChecks = function(revisionName, newPartialDocument, oldPartialDocument) {
    if (!((newPartialDocument.revision != null) && (newPartialDocument.revision[revisionName] != null) && (newPartialDocument._id != null))) {
      return new Error("unable to do a revisioned update with a newPartialDocument which does not contain the specified revision key (" + revisionName + "), or is missing _id");
    }
    if (!((oldPartialDocument.revision != null) && (oldPartialDocument.revision[revisionName] != null) && (oldPartialDocument._id != null))) {
      return new Error("unable to do a revisioned update with a oldPartialDocument which does not contain the specified revision key (" + revisionName + "), or is missing _id");
    }
    if (oldPartialDocument.revision[revisionName] !== newPartialDocument.revision[revisionName]) {
      return new Error("revision numbers between old and newPartialDocument must match (" + oldPartialDocument.revision[revisionName] + " isnt " + newPartialDocument.revision[revisionName]);
    }
    if (typeof oldPartialDocument.revision[revisionName] !== 'number') {
      return new Error("unable to do a revisioned update, revision." + revisionName + " isn't of type number");
    }
    return null;
  };

  exports.db = {
    pass: function(db, transaction, state, args, done) {
      return done(null, true);
    },
    updateOne: function(db, transaction, state, _arg, done) {
      var collectionName, etc, selector, values;
      collectionName = _arg[0], selector = _arg[1], values = _arg[2], etc = 4 <= _arg.length ? __slice.call(_arg, 3) : [];
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, false);
        }
        return collection.update(selector, values, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneField: function(db, transaction, state, _arg, done) {
      var collectionName, etc, field, selector, value;
      collectionName = _arg[0], selector = _arg[1], field = _arg[2], value = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var setter;
        if (err != null) {
          return done(err, false);
        }
        setter = {};
        setter[field] = value;
        return collection.update(selector, {
          $set: setter
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneFields: function(db, transaction, state, _arg, done) {
      var collectionName, etc, fieldValues, selector;
      collectionName = _arg[0], selector = _arg[1], fieldValues = _arg[2], etc = 4 <= _arg.length ? __slice.call(_arg, 3) : [];
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fieldValue, setter, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        setter = {};
        for (_i = 0, _len = fieldValues.length; _i < _len; _i++) {
          fieldValue = fieldValues[_i];
          setter[fieldValue.field] = fieldValue.value;
        }
        return collection.update(selector, {
          $set: setter
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    insert: function(db, transaction, state, _arg, done) {
      var collectionName, documents, etc;
      collectionName = _arg[0], documents = _arg[1], etc = 3 <= _arg.length ? __slice.call(_arg, 2) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to insert"));
      }
      if (!((collectionName != null) && (documents != null))) {
        return done(new Error("null or missing argument to insert command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, options, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        if (!Array.isArray(documents)) {
          documents = [documents];
        }
        state.ids = [];
        for (_i = 0, _len = documents.length; _i < _len; _i++) {
          d = documents[_i];
          if (d._id != null) {
            state.ids.push(d._id);
          } else {
            d._id = _pkFactory.createPk();
            state.ids.push(d._id);
          }
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        return _updateTransactionState(transaction, function(err) {
          if (err != null) {
            return done(err, null);
          }
          return collection.insert(documents, options, function(err, objects) {
            if (err != null) {
              return done(err, null);
            }
            return done(null, true);
          });
        });
      });
    },
    insertRollback: function(db, transaction, state, _arg, done) {
      var collectionName, documents, etc;
      collectionName = _arg[0], documents = _arg[1], etc = 3 <= _arg.length ? __slice.call(_arg, 2) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to insertRollback"));
      }
      if (!((collectionName != null) && (documents != null))) {
        return done(new Error("null or missing argument to insertRollback command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, i, iterator, options, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        if (state.ids == null) {
          return done(null, true);
        } else {
          if (!Array.isArray(documents)) {
            documents = [documents];
          }
          if (documents.length !== state.ids.length) {
            return done(new Error("during rollback, number of documents to insert doesnt match the number of ids generated during insert"), false);
          }
          for (i = _i = 0, _len = documents.length; _i < _len; i = ++_i) {
            d = documents[i];
            if (d._id == null) {
              d._id = state.ids[i];
            }
          }
          iterator = function(item, itemDone) {
            return collection.remove(item, options, function(err, result) {
              return itemDone(err);
            });
          };
          return async.each(documents, iterator, function(err) {
            return done(err, true);
          });
        }
      });
    },
    updateOneOp: function(db, transaction, state, _arg, done) {
      var collectionName, etc, rollbackOps, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackOps = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to updateOneOp"));
      }
      if (!((collectionName != null) && (selector != null) && (updateOps != null) && (rollbackOps != null))) {
        return done(new Error("null or missing argument to updateOneOp command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, false);
        }
        return collection.update(_mongolize(selector), _mongolize(updateOps), _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneOpRollback: function(db, transaction, state, _arg, done) {
      var collectionName, etc, rollbackOps, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackOps = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to updateOneOp"));
      }
      if (!((collectionName != null) && (selector != null) && (updateOps != null) && (rollbackOps != null))) {
        return done(new Error("null or missing argument to updateOneOp command"));
      }
      return exports.db.updateOneOp(db, transaction, state, [collectionName, selector, rollbackOps, {}], function(err, result) {
        return done(err, true);
      });
    },
    revisionedUpdate: function(db, transaction, state, _arg, done) {
      var collectionName, etc, newPartialDocument, oldPartialDocument, revisionName;
      collectionName = _arg[0], revisionName = _arg[1], newPartialDocument = _arg[2], oldPartialDocument = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to revisionedUpdate"));
      }
      if (!((collectionName != null) && (revisionName != null) && (newPartialDocument != null) && (oldPartialDocument != null))) {
        return done(new Error("null or missing argument to revisionedUpdate command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fail, fields, key, mongoOps, mongoSelector, revisionKey, value;
        if (err != null) {
          return done(err, false);
        }
        fail = _revisionedUpdateChecks(revisionName, newPartialDocument, oldPartialDocument);
        if (fail != null) {
          return done(fail);
        }
        revisionKey = "revision." + revisionName;
        mongoSelector = {
          _id: newPartialDocument._id
        };
        mongoSelector[revisionKey] = oldPartialDocument.revision[revisionName];
        fields = {};
        for (key in newPartialDocument) {
          value = newPartialDocument[key];
          if (key !== 'revision' && key !== '_id') {
            fields[key] = value;
          }
        }
        mongoOps = {
          $set: fields,
          $inc: {}
        };
        mongoOps.$inc[revisionKey] = 1;
        return collection.update(mongoSelector, mongoOps, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    revisionedUpdateRollback: function(db, transaction, state, _arg, done) {
      var collectionName, etc, newPartialDocument, oldPartialDocument, revisionName;
      collectionName = _arg[0], revisionName = _arg[1], newPartialDocument = _arg[2], oldPartialDocument = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to revisionedUpdateRollback"));
      }
      if (!((collectionName != null) && (revisionName != null) && (newPartialDocument != null) && (oldPartialDocument != null))) {
        return done(new Error("null or missing argument to revisionedUpdateRollback command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fail, key, newFields, oldFields, revisionKey, value;
        if (err != null) {
          return done(err, false);
        }
        fail = _revisionedUpdateChecks(revisionName, newPartialDocument, oldPartialDocument);
        if (fail != null) {
          return done(fail);
        }
        revisionKey = "revision." + revisionName;
        oldFields = {};
        oldFields[revisionKey] = oldPartialDocument.revision[revisionName];
        for (key in oldPartialDocument) {
          value = oldPartialDocument[key];
          if (key !== 'revision' && key !== '_id') {
            oldFields[key] = value;
          }
        }
        newFields = {};
        newFields[revisionKey] = newPartialDocument.revision[revisionName] + 1;
        for (key in newPartialDocument) {
          value = newPartialDocument[key];
          if (key !== 'revision') {
            newFields[key] = value;
          }
        }
        return collection.update(newFields, {
          $set: oldFields
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          return done(null, true);
        });
      });
    }
  };

  exports.transaction = function(queueName, username, implicitRollbackInstructions) {
    var transaction;
    if (implicitRollbackInstructions == null) {
      implicitRollbackInstructions = true;
    }
    return transaction = {
      softwareVersion: _softwareVersion,
      queue: queueName,
      position: 1,
      startedAt: null,
      enqueuedAt: null,
      lastUpdatedAt: null,
      enqueuedBy: username,
      status: "Queued",
      data: {},
      instructions: [],
      rollback: implicitRollbackInstructions ? null : [],
      execution: {
        state: [],
        errors: [],
        info: []
      }
    };
  };

}).call(this);
