// Generated by CoffeeScript 1.6.3
(function() {
  var DefaultPkFactory, ObjectID, applyToRegistered, async, commit, commitWithGlobalLock, execute, rollback, _checkTransaction, _clone, _commitCore, _db, _drainQueues, _enqueue, _enqueueOrCreateAndEnqueue, _executeImmediate, _hasAfter, _hasBefore, _immediateCounter, _immediately, _inSeries, _instructionsExistFor, _mongolize, _pending, _pendingImmediate, _pkFactory, _pushTransactionError, _queueCountersCollection, _queueLength, _queuePosition, _queues, _registry, _registryFind, _requeue, _retry, _revisionedUpdateChecks, _setUpTransaction, _shiftChain, _softwareVersion, _state, _transactionsCollection, _updateOneOptions, _updateTransactionState, _updateTransactionStatus, _withGlobalLock,
    __slice = [].slice;

  async = require('async');

  ObjectID = require('mongodb').ObjectID;

  _state = 'stopped';

  _queueLength = {};

  _immediateCounter = 0;

  _queues = null;

  _db = null;

  _registry = {};

  _pending = [];

  _pendingImmediate = [];

  _softwareVersion = null;

  _queueCountersCollection = null;

  _transactionsCollection = null;

  _pkFactory = null;

  DefaultPkFactory = (function() {
    function DefaultPkFactory() {}

    DefaultPkFactory.prototype.createPk = function() {
      return new ObjectID();
    };

    return DefaultPkFactory;

  })();

  _inSeries = function(cursor, fn, done) {
    var finished;
    finished = false;
    return async.doUntil(function(itemDone) {
      return cursor.nextObject(function(err, item) {
        if (item == null) {
          finished = true;
          return itemDone();
        } else {
          return fn(item, itemDone);
        }
      });
    }, function() {
      return finished;
    }, function(err) {
      return done(err);
    });
  };

  exports.start = function() {
    var db, done, optionals, tasks, _i;
    db = arguments[0], optionals = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
    if (_state !== 'stopped') {
      return done(new Error("committed has already been started"));
    }
    _softwareVersion = optionals[0];
    _pkFactory = optionals[1] != null ? new optionals[1]() : new DefaultPkFactory();
    _db = db;
    _queueLength = {};
    _immediateCounter = 0;
    _pending = [];
    _pendingImmediate = [];
    tasks = [];
    tasks.push(function(done) {
      return _db.createCollection('transactions', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _transactionsCollection = collection;
        return _db.ensureIndex('transactions', {
          status: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _db.createCollection('queueCounters', {
        w: 1,
        journal: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, null);
        }
        _queueCountersCollection = collection;
        return _db.ensureIndex('queueCounters', {
          queue: 1
        }, {
          w: 1,
          journal: true
        }, done);
      });
    });
    tasks.push(function(done) {
      return _inSeries(_transactionsCollection.find({
        status: 'Processing'
      }, {
        snapshot: true,
        sort: {
          position: 1
        }
      }), function(transaction, transactionDone) {
        return rollback(transaction(function(err, result) {
          if (err != null) {
            console.error(err.name, err.message, err.stack);
          }
          return transactionDone();
        }));
      }, done);
    });
    tasks.push(function(done) {
      return _inSeries(_transactionsCollection.find({
        status: 'Committed',
        "after.0.status": 'Queued'
      }, {
        snapshot: true
      }), function(transaction, transactionDone) {
        _shiftChain(transaction);
        return _transactionsCollection.save(transaction, {
          w: 1,
          journal: true
        }, function(err, result) {
          if (err != null) {
            console.error(err.name, err.message, err.stack);
          }
          return transactionDone();
        });
      }, done);
    });
    tasks.push(function(done) {
      return _inSeries(_transactionsCollection.find({
        $or: [
          {
            status: 'Queued'
          }, {
            status: 'Committed',
            "after.0.status": 'Queued'
          }
        ]
      }, {
        snapshot: true,
        sort: {
          position: 1
        }
      }), function(transaction, transactionDone) {
        return commit(transaction, function(err, result) {
          if (err != null) {
            console.error(err.name, err.message, err.stack);
          }
          return transactionDone();
        });
      }, done);
    });
    return async.series(tasks, function(err, results) {
      if (err != null) {
        return done(err);
      }
      _queues = {
        GlobalLock: async.queue(commitWithGlobalLock, 1)
      };
      _queueLength.GlobalLock = 0;
      _queues.GlobalLock.drain = function() {
        var transaction, _ref, _ref1, _results;
        _state = 'started';
        while (_pending.length !== 0) {
          _ref = _pending.shift(), transaction = _ref[0], done = _ref[1];
          _enqueueOrCreateAndEnqueue(transaction.queue, transaction, done);
        }
        _results = [];
        while (_pendingImmediate.length !== 0) {
          _ref1 = _pendingImmediate.shift(), transaction = _ref1[0], done = _ref1[1];
          _results.push(_executeImmediate(transaction, done));
        }
        return _results;
      };
      _state = 'started';
      return done(null);
    });
  };

  exports.stop = function(done) {
    if (_state === 'stopped') {
      return done(new Error("committed is not currently started"));
    }
    return setImmediate(function() {
      var name;
      _state = 'stopped';
      return _drainQueues((function() {
        var _results;
        _results = [];
        for (name in _queues) {
          _results.push(name);
        }
        return _results;
      })(), done);
    });
  };

  _drainQueues = function(queues, done) {
    return async.until(function() {
      var name;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = queues.length; _i < _len; _i++) {
          name = queues[_i];
          _results.push(_queueLength[name] === 0);
        }
        return _results;
      })()).every(function(x) {
        return x;
      }) && _immediateCounter === 0;
    }, function(untilBodyDone) {
      return setTimeout(untilBodyDone, 10);
    }, function(err) {
      return done(err);
    });
  };

  exports.register = function(name, fnOrObj) {
    var ancestor, ancestors, key, parent, _i, _len;
    parent = _registry;
    ancestors = name.split('.');
    key = ancestors.pop();
    for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
      ancestor = ancestors[_i];
      parent = parent[ancestor];
      if (parent == null) {
        throw new Error("during register: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry)));
      }
    }
    if (parent[key] != null) {
      throw new Error("during register: path " + name + " already exists in registry: " + (JSON.stringify(_registry)));
    }
    return parent[key] = fnOrObj;
  };

  _queuePosition = function(queueName, done) {
    return _queueCountersCollection.findAndModify({
      queue: queueName
    }, {}, {
      $inc: {
        nextPosition: 1
      }
    }, {
      upsert: true,
      w: 1,
      journal: true
    }, function(err, doc) {
      var _ref;
      if (err != null) {
        return done(err, null);
      }
      return done(null, (_ref = doc.nextPosition) != null ? _ref : 0);
    });
  };

  _enqueueOrCreateAndEnqueue = function(queueName, transaction, done) {
    if (_queues[queueName] == null) {
      _queues[queueName] = async.queue(commit, 1);
      _queueLength[queueName] = 0;
    }
    _queueLength[queueName] += 1;
    return _queues[queueName].push(transaction, function() {
      var etc;
      etc = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _queueLength[queueName] -= 1;
      return done.apply(null, etc);
    });
  };

  _checkTransaction = function(transaction) {
    if ((transaction.status != null) && transaction.status !== 'Queued') {
      return new Error("Can't queue a transaction which is at a status other than Queued (or null)");
    }
    if (!_instructionsExistFor(transaction)) {
      return new Error("Can't queue a transaction for which either its instructions, rollback instructions, or implied auto rollback instructions don't exist in the registry");
    }
    if ((transaction.rollback != null) && transaction.rollback.length !== transaction.instructions.length) {
      return new Error("Can't queue a transaction with an explicit rollback instructions whose length is not the same as its instructions array");
    }
    if ((transaction.after != null) && !transaction.after.every(function(x) {
      return (x.status != null) && x.status === 'Queued';
    })) {
      return new Error("Can't queue a transaction chain where one transaction is at a status other than Queued");
    }
  };

  _instructionsExistFor = function(transaction) {
    var i, _i, _j, _len, _len1, _ref, _ref1;
    if (transaction.rollback != null) {
      _ref = transaction.instructions.concat(transaction.rollback);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (_registryFind(i.name) == null) {
          return false;
        }
      }
    } else {
      _ref1 = transaction.instructions;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        i = _ref1[_j];
        if (_registryFind(i.name) == null) {
          return false;
        }
        if (_registryFind(i.name + 'Rollback') == null) {
          return false;
        }
      }
    }
    return true;
  };

  _setUpTransaction = function(transaction) {
    var i, iRoll, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (transaction.rollback == null) {
      transaction.rollback = [];
      _ref = transaction.instructions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        iRoll = _clone(i);
        iRoll.name = iRoll.name + 'Rollback';
        transaction.rollback.push(iRoll);
      }
    }
    transaction.execution.state = [];
    _ref1 = transaction.instructions;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      i = _ref1[_j];
      _results.push(transaction.execution.state.push({}));
    }
    return _results;
  };

  _enqueue = function(transaction, done) {
    var error, _ref;
    transaction.enqueuedAt = new Date();
    if (transaction.queue === "GlobalLock") {
      return done(new Error("Can't queue a transaction for GlobalLock using the committed.enqueue function"), null);
    }
    if (!((_ref = transaction.queue) != null ? _ref.length : void 0)) {
      return done(new Error("must have a transaction.queue parameter to use committed.enqueue"), null);
    }
    error = _checkTransaction(transaction);
    if (error != null) {
      return done(error, null);
    }
    transaction.status = 'Queued';
    if (_state !== 'locked') {
      return _enqueueOrCreateAndEnqueue(transaction.queue, transaction, done);
    } else {
      return _pending.push([transaction, done]);
    }
  };

  exports.enqueue = function(transaction, done) {
    return setImmediate(function() {
      if (_state === 'stopped') {
        transaction.status = 'Failed';
        transaction.execution.info.push("unable to enquue transaction, committed was at state '" + _state + "'");
        return done(null, 'Failed');
      } else {
        return _enqueue(transaction, done);
      }
    });
  };

  exports.immediately = function(transaction, done) {
    return setImmediate(function() {
      if (_state === 'stopped') {
        transaction.status = 'Failed';
        transaction.execution.info.push("unable to execute transaction immediately, committed was at state '" + _state + "'");
        return done(null, 'Failed');
      } else {
        return _immediately(transaction, done);
      }
    });
  };

  _executeImmediate = function(transaction, done) {
    _immediateCounter += 1;
    return commit(transaction, function() {
      var etc;
      etc = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _immediateCounter -= 1;
      return done.apply(null, etc);
    });
  };

  _immediately = function(transaction, done) {
    var error;
    transaction.enqueuedAt = new Date();
    if (transaction.queue != null) {
      return done(new Error("Can't call committed.immediately on a transaction which has a queue defined for it"));
    }
    error = _checkTransaction(transaction);
    if (error != null) {
      return done(error, null);
    }
    if (_state !== 'locked') {
      transaction.status = 'Queued';
      transaction.position = -1;
      _setUpTransaction(transaction);
      return _executeImmediate(transaction, done);
    } else {
      return _pendingImmediate.push([transaction, done]);
    }
  };

  _withGlobalLock = function(transaction, done) {
    var error;
    if (transaction.queue !== "GlobalLock") {
      return done(new Error("Can't call committed.withGlobalLock for a transaction that names a queue other than 'GlobalLock'"), null);
    }
    error = _checkTransaction(transaction);
    if (error != null) {
      return done(error, null);
    }
    transaction.enqueuedAt = new Date();
    return _enqueueOrCreateAndEnqueue(transaction.queue, transaction, done);
  };

  exports.withGlobalLock = function(transaction, done) {
    return setImmediate(function() {
      if (_state === 'stopped') {
        transaction.status = "Failed";
        transaction.execution.info.push("unable to enqueue transaction withGlobalLock, committed was at state '" + _state + "'");
        return done(null, 'Failed');
      } else {
        transaction.status = "Queued";
        _state = 'locked';
        return _withGlobalLock(transaction, done);
      }
    });
  };

  _registryFind = function(name) {
    var found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        return null;
      }
    }
    return found;
  };

  applyToRegistered = function(name, fnArgs) {
    var done, found, key, _i, _len, _ref;
    found = _registry;
    _ref = name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      found = found[key];
      if (found == null) {
        done = fnArgs[fnArgs.length - 1];
        return done(new Error("during applyToRegistered: path " + name + " doesn't exist in registry: " + (JSON.stringify(_registry))));
      }
    }
    return found.apply(this, fnArgs);
  };

  execute = function(instructions, state, transaction, done) {
    var i, instruction, instructionsWithState, iterator, results;
    results = [];
    iterator = function(_arg, iteratorDone) {
      var args, fnArgs, instruction, state;
      instruction = _arg[0], state = _arg[1];
      args = instruction["arguments"] != null ? instruction["arguments"] : [];
      if (!Array.isArray(args)) {
        args = [args];
      }
      fnArgs = [_db, transaction, state, args];
      fnArgs.push(function(err, iteratorResult) {
        if ((err == null) && iteratorResult === false) {
          err = 'instructionFailed';
        }
        results.push(iteratorResult);
        return iteratorDone(err);
      });
      return applyToRegistered(instruction.name, fnArgs);
    };
    instructionsWithState = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = instructions.length; _i < _len; i = ++_i) {
        instruction = instructions[i];
        _results.push([instruction, state[i]]);
      }
      return _results;
    })();
    return async.eachSeries(instructionsWithState, iterator, function(err) {
      if (err === 'instructionFailed') {
        err = null;
      }
      return done(err, results);
    });
  };

  _pushTransactionError = function() {
    var done, error, mongoOps, optional, results, rollbackResults, serialisedError, transaction, _i;
    transaction = arguments[0], error = arguments[1], optional = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), done = arguments[_i++];
    if (optional != null) {
      results = optional[0], rollbackResults = optional[1];
    }
    if ((error.name != null) && (error.stack != null) && (error.message != null)) {
      serialisedError = {
        name: error.name,
        message: error.message,
        stack: error.stack
      };
    } else {
      serialisedError = error.toString();
    }
    mongoOps = {
      $push: {
        'execution.errors': serialisedError
      }
    };
    transaction.execution.errors.push(serialisedError);
    if (results != null) {
      transaction.execution.results = results;
      if (mongoOps.$set == null) {
        mongoOps.$set = {};
      }
      mongoOps.$set['execution.results'] = results;
    }
    if (rollbackResults != null) {
      transaction.execution.rollback = rollbackResults;
      if (mongoOps.$set == null) {
        mongoOps.$set = {};
      }
      mongoOps.$set['execution.rollback'] = rollbackResults;
    }
    return _transactionsCollection.update({
      _id: transaction._id
    }, mongoOps, {
      w: 1,
      journal: true
    }, function(err, updated) {
      if (err != null) {
        console.log("error saving error to transaction: " + err);
      }
      return done();
    });
  };

  _updateTransactionStatus = function() {
    var done, fromStatus, optional, results, rollbackResults, toStatus, transaction, updatedAt, _i;
    transaction = arguments[0], fromStatus = arguments[1], toStatus = arguments[2], optional = 5 <= arguments.length ? __slice.call(arguments, 3, _i = arguments.length - 1) : (_i = 3, []), done = arguments[_i++];
    if (optional != null) {
      results = optional[0], rollbackResults = optional[1];
    }
    updatedAt = new Date();
    if (results != null) {
      transaction.execution.results = results;
    }
    if (rollbackResults != null) {
      transaction.execution.rollback = rollbackResults;
    }
    return _transactionsCollection.update({
      _id: transaction._id,
      status: fromStatus
    }, {
      $set: {
        status: toStatus,
        softwareVersion: _softwareVersion,
        enqueuedAt: transaction.enqueuedAt,
        startedAt: transaction.startedAt,
        lastUpdatedAt: updatedAt,
        execution: transaction.execution
      }
    }, {
      w: 1,
      journal: true
    }, function(err, updated) {
      var updateError;
      switch (false) {
        case err == null:
          return _pushTransactionError(transaction, err, function() {
            return done(err);
          });
        case updated === 1:
          updateError = new Error("exactly one transaction must be updated when moving from " + fromStatus + " to " + toStatus + " status");
          return _pushTransactionError(transaction, updateError, function() {
            return done(updateError);
          });
        default:
          transaction.softwareVersion = _softwareVersion;
          transaction.status = toStatus;
          transaction.lastUpdatedAt = updatedAt;
          return done(null);
      }
    });
  };

  _updateTransactionState = function(transaction, done) {
    return _transactionsCollection.update({
      _id: transaction._id
    }, {
      $set: {
        'executions.state': transaction.execution.state
      }
    }, _updateOneOptions, function(err, updated) {
      if ((err == null) && updated !== 1) {
        err = new Error("transaction not correctly updated with instruction state before insert");
      }
      return done(err);
    });
  };

  _clone = function(obj, mongolize) {
    var flags, key, newInstance, value, x;
    if (mongolize == null) {
      mongolize = false;
    }
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Array) {
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          x = obj[_i];
          _results.push(_clone(x, mongolize));
        }
        return _results;
      })();
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      value = obj[key];
      if (mongolize && key.indexOf('__') === 0) {
        newInstance['$' + key.slice(2)] = _clone(value, mongolize);
      } else {
        newInstance[key] = _clone(value, mongolize);
      }
    }
    return newInstance;
  };

  _mongolize = function(obj) {
    return _clone(obj, true);
  };

  rollback = function(transaction, done) {
    var rollbackInstructions, rollbackLength, rollbackState;
    if (transaction.status !== 'Processing') {
      return done(new Error("can't rollback a transaction that isn't at 'Processing' status"), null);
    }
    rollbackLength = transaction.execution.results != null ? transaction.execution.results.length : transaction.instructions.length;
    rollbackInstructions = transaction.rollback.slice(0, rollbackLength);
    rollbackState = transaction.execution.state.slice(0, rollbackLength);
    rollbackInstructions.reverse();
    rollbackState.reverse();
    return execute(rollbackInstructions, rollbackState, transaction, function(rollbackErr, rollbackResults) {
      var failed, newStatus;
      failed = (rollbackErr != null) || !rollbackResults.every(function(x) {
        return x;
      });
      switch (false) {
        case !(failed && transaction.execution.errors.length > 0):
          newStatus = 'CatastropheCommitErrorRollbackError';
          break;
        case !(failed && transaction.execution.errors.length === 0):
          newStatus = 'CatastropheCommitFailedRollbackError';
          break;
        case !(!failed && transaction.execution.errors.length > 0):
          newStatus = 'FailedCommitErrorRollbackOk';
          break;
        case !(!failed && transaction.execution.errors.length === 0):
          newStatus = 'Failed';
      }
      return _updateTransactionStatus(transaction, 'Processing', newStatus, null, rollbackResults, function(statusErr) {
        if (statusErr != null) {
          return done(statusErr, newStatus);
        } else if (rollbackErr != null) {
          return _pushTransactionError(transaction, rollbackErr, function() {
            return done(rollbackErr, newStatus);
          });
        } else {
          return done(null, newStatus);
        }
      });
    });
  };

  commitWithGlobalLock = function(transaction, done) {
    var name;
    return _drainQueues((function() {
      var _results;
      _results = [];
      for (name in _queues) {
        if (name !== 'GlobalLock') {
          _results.push(name);
        }
      }
      return _results;
    })(), function(err) {
      if (err != null) {
        return done(err, null);
      }
      return commit(transaction, done);
    });
  };

  _requeue = function(transaction, done) {
    if (transaction.queue === 'GlobalLock') {
      return _withGlobalLock(transaction, done);
    } else {
      return _enqueue(transaction, done);
    }
  };

  _hasAfter = function(transaction) {
    return (transaction.after != null) && transaction.after.length !== 0;
  };

  _hasBefore = function(transaction) {
    return (transaction.before != null) && transaction.before.length !== 0;
  };

  _shiftChain = function(transaction) {
    var copyTransaction, key, nextTransaction, value, _results;
    nextTransaction = transaction.after.shift();
    copyTransaction = {};
    for (key in transaction) {
      value = transaction[key];
      if (key !== 'before' && key !== 'after' && key !== '_id') {
        copyTransaction[key] = value;
        transaction[key] = void 0;
      }
    }
    transaction.before.push(copyTransaction);
    _results = [];
    for (key in nextTransaction) {
      value = nextTransaction[key];
      if (key !== 'before' && key !== 'after' && key !== '_id') {
        _results.push(transaction[key] = value);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _retry = function(transaction, retryFn, failFn) {};

  commit = function(transaction, done, retries) {
    if (retries == null) {
      retries = 2;
    }
    return _commitCore(transaction, function(err, status) {
      if (!(_hasBefore(transaction) || _hasAfter(transaction))) {
        return done(err, status);
      } else {
        switch (status) {
          case 'Committed':
            if (_hasAfter(transaction)) {
              _shiftChain(transaction);
              return _requeue(transaction, done);
            } else {
              return done(err, status);
            }
            break;
          case 'Failed':
          case 'FailedCommitErrorRollbackOk':
            if (!_hasBefore(transaction)) {
              return done(err, status);
            } else {
              if (retries > 0) {
                setTimeout(function() {
                  return _updateTransactionStatus(transaction, transaction.status, 'Queued', null, null, "" + status + " " + retries + " retries remaining", function(statusErr) {
                    if (statusErr != null) {
                      return done(statusErr, transaction.status);
                    }
                    return commit(transaction, done, retries - 1);
                  });
                }, 500 + Math.floor(1000 * Math.random()));
                return null;
              } else {
                return _updateTransactionStatus(transaction, transaction.status, 'ChainFailed', null, null, transaction.status, function(statusErr) {
                  if (statusErr != null) {
                    return done(statusErr, transaction.status);
                  }
                  return done(err, 'ChainFailed');
                });
              }
            }
            break;
          default:
            if (!_hasBefore(transaction)) {
              return done(err, status);
            } else {
              return _updateTransactionStatus(transaction, transaction.status, 'ChainFailed', null, null, transaction.status, function(statusErr) {
                if (statusErr != null) {
                  return done(statusErr, transaction.status);
                }
                return done(err, 'ChainFailed');
              });
            }
        }
      }
    });
  };

  _commitCore = function(transaction, done) {
    if (transaction.status !== 'Queued') {
      return done(new Error("can't begin work on a transaction which isn't at 'Queued' status (" + transaction.status + ")"), null);
    }
    return _queuePosition(transaction.queue, function(err, position) {
      transaction.position = position;
      transaction.status = 'Processing';
      transaction.startedAt = new Date();
      _setUpTransaction(transaction);
      if (transaction._id == null) {
        transaction._id = _pkFactory.createPk();
      }
      return _transactionsCollection.update({
        _id: transaction._id,
        'after.0.status': 'Queued'
      }, transaction, {
        upsert: true,
        w: 1
      }, function(err, changed) {
        if ((err == null) && changed !== 1) {
          err = new Error("upsert transaction must effect exactly one document");
        }
        if (err != null) {
          return done(err, null);
        }
        return execute(transaction.instructions, transaction.execution.state, transaction, function(err, results) {
          if (err != null) {
            return _pushTransactionError(transaction, err, results, function() {
              return rollback(transaction, done);
            });
          } else if (results.length === transaction.instructions.length && results.every(function(x) {
            return x;
          })) {
            return _updateTransactionStatus(transaction, 'Processing', 'Committed', results, function(err) {
              if (err != null) {
                _transactionsCollection.findOne({
                  _id: transaction._id
                }, function(err, doc) {});
              }
              return done(err, 'Committed');
            });
          } else {
            return _updateTransactionStatus(transaction, transaction.status, transaction.status, results, null, "legitimate transaction failure", function(statusErr) {
              if (err != null) {
                console.error("error saving transaction status change on legitimate failure: " + err);
              }
              return rollback(transaction, done);
            });
          }
        });
      });
    });
  };

  _updateOneOptions = {
    w: 1,
    journal: true,
    upsert: false,
    multi: false,
    serializeFunctions: false
  };

  _revisionedUpdateChecks = function(revisionName, newPartialDocument, oldPartialDocument) {
    if (!((newPartialDocument.revision != null) && (newPartialDocument.revision[revisionName] != null) && (newPartialDocument._id != null))) {
      return new Error("unable to do a revisioned update with a newPartialDocument which does not contain the specified revision key (" + revisionName + "), or is missing _id");
    }
    if (!((oldPartialDocument.revision != null) && (oldPartialDocument.revision[revisionName] != null) && (oldPartialDocument._id != null))) {
      return new Error("unable to do a revisioned update with a oldPartialDocument which does not contain the specified revision key (" + revisionName + "), or is missing _id");
    }
    if (oldPartialDocument.revision[revisionName] !== newPartialDocument.revision[revisionName]) {
      return new Error("revision numbers between old and newPartialDocument must match (" + oldPartialDocument.revision[revisionName] + " isnt " + newPartialDocument.revision[revisionName]);
    }
    if (typeof oldPartialDocument.revision[revisionName] !== 'number') {
      return new Error("unable to do a revisioned update, revision." + revisionName + " isn't of type number");
    }
    return null;
  };

  exports.db = {
    pass: function(db, transaction, state, args, done) {
      return done(null, true);
    },
    insert: function(db, transaction, state, _arg, done) {
      var collectionName, documents, etc;
      collectionName = _arg[0], documents = _arg[1], etc = 3 <= _arg.length ? __slice.call(_arg, 2) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to insert"));
      }
      if (!((collectionName != null) && (documents != null))) {
        return done(new Error("null or missing argument to insert command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, options, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        if (!Array.isArray(documents)) {
          documents = [documents];
        }
        state.ids = [];
        for (_i = 0, _len = documents.length; _i < _len; _i++) {
          d = documents[_i];
          if (d._id != null) {
            state.ids.push(d._id);
          } else {
            d._id = _pkFactory.createPk();
            state.ids.push(d._id);
          }
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        return _updateTransactionState(transaction, function(err) {
          if (err != null) {
            return done(err, null);
          }
          return collection.insert(documents, options, function(err, objects) {
            if (err != null) {
              return done(err, null);
            }
            return done(null, true);
          });
        });
      });
    },
    insertRollback: function(db, transaction, state, _arg, done) {
      var collectionName, documents, etc;
      collectionName = _arg[0], documents = _arg[1], etc = 3 <= _arg.length ? __slice.call(_arg, 2) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to insertRollback"));
      }
      if (!((collectionName != null) && (documents != null))) {
        return done(new Error("null or missing argument to insertRollback command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var d, i, iterator, options, _i, _len;
        if (err != null) {
          return done(err, false);
        }
        options = {
          w: 1,
          journal: true,
          serializeFunctions: false
        };
        if (state.ids == null) {
          return done(null, true);
        } else {
          if (!Array.isArray(documents)) {
            documents = [documents];
          }
          if (documents.length !== state.ids.length) {
            return done(new Error("during rollback, number of documents to insert doesnt match the number of ids generated during insert"), false);
          }
          for (i = _i = 0, _len = documents.length; _i < _len; i = ++_i) {
            d = documents[i];
            if (d._id == null) {
              d._id = state.ids[i];
            }
          }
          iterator = function(item, itemDone) {
            return collection.remove(item, options, function(err, result) {
              return itemDone(err);
            });
          };
          return async.each(documents, iterator, function(err) {
            return done(err, true);
          });
        }
      });
    },
    updateOneOp: function(db, transaction, state, _arg, done) {
      var collectionName, etc, rollbackOps, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackOps = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to updateOneOp"));
      }
      if (!((collectionName != null) && (selector != null) && (updateOps != null) && (rollbackOps != null))) {
        return done(new Error("null or missing argument to updateOneOp command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        if (err != null) {
          return done(err, false);
        }
        return collection.update(_mongolize(selector), _mongolize(updateOps), _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    updateOneOpRollback: function(db, transaction, state, _arg, done) {
      var collectionName, etc, rollbackOps, selector, updateOps;
      collectionName = _arg[0], selector = _arg[1], updateOps = _arg[2], rollbackOps = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to updateOneOp"));
      }
      if (!((collectionName != null) && (selector != null) && (updateOps != null) && (rollbackOps != null))) {
        return done(new Error("null or missing argument to updateOneOp command"));
      }
      return exports.db.updateOneOp(db, transaction, state, [collectionName, selector, rollbackOps, {}], function(err, result) {
        return done(err, true);
      });
    },
    revisionedUpdate: function(db, transaction, state, _arg, done) {
      var collectionName, etc, newPartialDocument, oldPartialDocument, revisionName;
      collectionName = _arg[0], revisionName = _arg[1], newPartialDocument = _arg[2], oldPartialDocument = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to revisionedUpdate"));
      }
      if (!((collectionName != null) && (revisionName != null) && (newPartialDocument != null) && (oldPartialDocument != null))) {
        return done(new Error("null or missing argument to revisionedUpdate command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fail, fields, key, mongoOps, mongoSelector, revisionKey, value;
        if (err != null) {
          return done(err, false);
        }
        fail = _revisionedUpdateChecks(revisionName, newPartialDocument, oldPartialDocument);
        if (fail != null) {
          return done(fail);
        }
        revisionKey = "revision." + revisionName;
        mongoSelector = {
          _id: newPartialDocument._id
        };
        mongoSelector[revisionKey] = oldPartialDocument.revision[revisionName];
        fields = {};
        for (key in newPartialDocument) {
          value = newPartialDocument[key];
          if (key !== 'revision' && key !== '_id') {
            fields[key] = value;
          }
        }
        mongoOps = {
          $set: fields,
          $inc: {}
        };
        mongoOps.$inc[revisionKey] = 1;
        return collection.update(mongoSelector, mongoOps, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          if (updated !== 1) {
            return done(null, false);
          }
          return done(null, true);
        });
      });
    },
    revisionedUpdateRollback: function(db, transaction, state, _arg, done) {
      var collectionName, etc, newPartialDocument, oldPartialDocument, revisionName;
      collectionName = _arg[0], revisionName = _arg[1], newPartialDocument = _arg[2], oldPartialDocument = _arg[3], etc = 5 <= _arg.length ? __slice.call(_arg, 4) : [];
      if (etc.length !== 0) {
        return done(new Error("too many values passed to revisionedUpdateRollback"));
      }
      if (!((collectionName != null) && (revisionName != null) && (newPartialDocument != null) && (oldPartialDocument != null))) {
        return done(new Error("null or missing argument to revisionedUpdateRollback command"));
      }
      return db.collection(collectionName, {
        strict: true
      }, function(err, collection) {
        var fail, key, newFields, oldFields, revisionKey, value;
        if (err != null) {
          return done(err, false);
        }
        fail = _revisionedUpdateChecks(revisionName, newPartialDocument, oldPartialDocument);
        if (fail != null) {
          return done(fail);
        }
        revisionKey = "revision." + revisionName;
        oldFields = {};
        oldFields[revisionKey] = oldPartialDocument.revision[revisionName];
        for (key in oldPartialDocument) {
          value = oldPartialDocument[key];
          if (key !== 'revision' && key !== '_id') {
            oldFields[key] = value;
          }
        }
        newFields = {};
        newFields[revisionKey] = newPartialDocument.revision[revisionName] + 1;
        for (key in newPartialDocument) {
          value = newPartialDocument[key];
          if (key !== 'revision') {
            newFields[key] = value;
          }
        }
        return collection.update(newFields, {
          $set: oldFields
        }, _updateOneOptions, function(err, updated) {
          if (err != null) {
            return done(err, null);
          }
          return done(null, true);
        });
      });
    }
  };

  exports.transaction = function(queueName, username, instructions, rollback) {
    var transaction;
    return transaction = {
      softwareVersion: _softwareVersion,
      queue: queueName,
      position: null,
      startedAt: null,
      enqueuedAt: null,
      lastUpdatedAt: null,
      enqueuedBy: username,
      status: "Queued",
      data: {},
      instructions: instructions != null ? instructions : [],
      rollback: rollback,
      execution: {
        state: [],
        errors: [],
        info: [],
        results: null,
        rollback: null
      }
    };
  };

  exports.chain = function(transactions) {
    var first;
    if (!Array.isArray(transactions) || transactions.length === 0) {
      throw new Error("to chain transactions an array of transactions must be provided");
    }
    first = transactions[0];
    first.before = [];
    first.after = transactions.slice(1);
    return first;
  };

}).call(this);
